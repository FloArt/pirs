#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <math.h>
#include <map>
#include "gzstream.h"
#include "simulate_illumina_reads.h"
#include "simulate.h"
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>


using namespace std;
using namespace boost; 

string input_ref1;
string input_ref2;
string error_profile;
string GC_depth_file;
int read_length=100;
double coverage=40;
int insertsize_mean=500;
int insertsize_sd=-1;
double error_rate=-1;
int Is_cyclization = 0;
int Is_simulate_GC_bias = 1;
int Is_simulate_quality = 1;
int output_type = 1;
string output_prefix = "illumina";
string error_profile_name = "hum20110701.bwanosnp.count.matrix";
string GC_depth_profile_name = "stat_100.dat.gc";

int Ref_Base_num;
int Statistical_Cycle_num; //统计矩阵的CYCLE总数
int Seq_Base_num;
int Quality_num;

int Simulate_Cycle_num; //用户模拟的CYCLE总数

double Statistical_average_error_rate = 0.0;

ogzstream gz_outfile1;
ogzstream gz_outfile2;
ofstream outfile1;
ofstream outfile2;

double*** simulation_matrix = NULL;

double* GC_bias_abundance;

uint64_t error_total_num = 0;
map<int,uint64_t> InsertSize_distr;
uint64_t* error_pos_distr;
double* Q_to_Erate_distr;
uint64_t total_read_pair = 0;

const char *MAKE_TIME="2011-08-03";
const char *VERSION="3.0";
const char *CONTACT1="yuanjianying@genomics.org.cn";
const char *CONTACT2="shiyujian@genomics.org.cn";

void Usage(){
	cout<<"Description:"<<endl;
	cout<<"   It is a program for simulating illumina PE reads, with a series of problems generate by illumina ";
	cout<<"sequencing machine, such as insertsize distribution, sequencing error and quality score, GC bias. ";
	cout<<"User should set the value of insertsize_mean and insertsize_sd, they are the mean value and standard ";
	cout<<"deviation of the normal distribution that used as the model function when simulating insertsize ";
	cout<<"distribution, usually we set the insertsize_sd to be 1/20 of the insertsize_mean. The normal distribution ";
	cout<<"function model we used in this program is f(x)=1/σ/sqrt(2*pi)*exp((x-μ)**2 / (2*σ**2)), and the insertsize ";
	cout<<"distribution is simulated by Box-muller method. ";
	cout<<"This program simulate illumina sequencing error and quality score according to the error profile. ";
	cout<<"User can set the path of error profile or using the default file in this program package, which is generated by large real sequencing data in this program package. ";
	cout<<"If you want to simulate diploid(heterozygosis SNP and heterozygosis Indel) reads, you should input two ";
	cout<<"reference sequence, you can get the snp&indel sequence by the program \"simulate_snp_indel_seq\", but ";
	cout<<"remember that heterozygosis SNP rate and heterozygosis Indel rate is only exists in diploid. ";
	cout<<"At last, you should set another several parameters, read length, coverage of reads, input sequence, ";
	cout<<"output prefix and so on, the option -i must be set, because there is not default value."<<endl;
	cout<<endl<<"Program:simulate_illumina_reads"<<endl;
	cout<<"\tCompile Data: "<<MAKE_TIME<<endl;
	cout<<"\tHistory and contributions: "<<endl;
	cout<<"\t\tVersion 1.0: Lu jianliang and Yue zhen, 2010-03-01. "<<endl;
	cout<<"\t\tVersion 2.0: Fan Wei, Shi Yujian, Hu Xuesong, Yuan Jianying, 2011-07-07."<<endl;
	cout<<"\t\tVersion 3.0: Fan Wei, Shi Yujian, Hu Xuesong, Yuan Jianying, 2011-08-03."<<endl;
	cout<<"\tVersion: "<<VERSION<<endl;
	cout<<"\tContact: "<<CONTACT1<<" "<<CONTACT2<<endl;
	cout<<endl<<"Usage:\tsimulate_illumina_reads [options]"<<endl;
	cout<<"\t-i  <string>  input_ref1,input reference genome sequence *.fa/*.fa.gz, no default vaule"<<endl;
	cout<<"\t-I  <string>  input_ref2,for diploid genome, input another reference genome sequence which was generated by program \"simulate_snp_indel_seq\""<<endl;
	cout<<"\t-s  <string>  error_profile,input error profile,default: (exe_path)/statistical_file_package/error_profile/"<<error_profile_name<<endl;
	cout<<"\t-d  <string>  GC depth file,input GC depth file for simulate GC bias,default: (exe_path)/statistical_file_package/GC_depth_profile/"<<GC_depth_profile_name<<endl;
	cout<<"\t-l  <int>     read_len,set read length,read1 and read2 have the same length,default:"<<read_length<<endl;
	cout<<"\t-x  <double>  coverage,set the sequencing coverage(sometimes called depth),default:"<<coverage<<endl;
	cout<<"\t-m  <int>     insertsize_mean,set the average value of insert size,default:"<<insertsize_mean<<endl;
	cout<<"\t-v  <int>     insertsize_sd,set the standard deviation of insert sizes, default:insertsize_mean/20"<<endl;
	cout<<"\t-e  <double>  error_rate,set the average error rate over all cycles,default=error profile average error ratio"<<endl;
	cout<<"\t-g  <int>     whether simulate GC bias, 0:no, 1:yes, default:"<<Is_simulate_GC_bias<<endl;
	cout<<"\t-q  <int>     whether simulate quality value, 0:no, 1:yes, default:"<<Is_simulate_quality<<endl;
	cout<<"\t-f  <int>     whether cyclize insert sequence(influence on PE-reads direction) 0: read1-forward read2-reverse, 1: read1-reverse read2-forward, default:"<<Is_cyclization<<endl;
	cout<<"\t-c  <int>     set output file type, 0:text, 1:*.gz, default:"<<output_type<<endl;
	cout<<"\t-o  <string>  output,output file prefix default:"<<output_prefix<<endl;
	cout<<"\t-h            output help infomation."<<endl;
	cout<<endl<<"Example:"<<endl;
	cout<<endl<<"\t1. ./simulate_illumina_reads -i ref_sequence.fa"<<endl;
	cout<<"\t  Every parameter use the default one."<<endl;
	cout<<"\t2. ./simulate_illumina_reads -i ref_sequence.fa -l 100 -x 20 -o human_500_100"<<endl;
	cout<<"\t  Just set read length and coverage you needed."<<endl;
	cout<<"\t3. ./simulate_illumina_reads -i ref_sequence.fa -o human -m 600 -v 30 -e 0.01"<<endl;
	cout<<"\t  Set insertsize distribution and error rate."<<endl;
	cout<<"\t4. ./simulate_illumina_reads -i ref_sequence.fa -I snp_indel_ref_sequence.fa -o human "<<endl;
	cout<<"\t  The genome is diploid and you want to produce heterozygosis SNPs  heterozygosis Indels in reads, "<<endl;
	cout<<"\t  the -I input was generated by program \"simulate_snp_indel_seq\"."<<endl;
	cout<<"\t5. ./simulate_illumina_reads -i ref_sequence.fa -g 1 -f 1 -c 0 -o human "<<endl;
	cout<<"\t  Set simulate GCbias and the library is cyclization, output file is text format."<<endl;
	cout<<"\t6. ./simulate_illumina_reads -i ref_sequence.fa -q 1 -o human "<<endl;
	cout<<"\t  Set simulate quality value, the ouput is in *.fq format."<<endl;
	exit(-1);
}

//convert to uint64_t type
uint64_t toUint64_t(string a)
{
	std::stringstream ss;
  ss << a;
  uint64_t b = 0;
  ss >> b;
  ss.clear();
  return b;
}

void Getopt(int argc,char *argv[]){
	int c;
	while ((c=getopt(argc,argv,"i:I:s:d:l:x:m:v:e:f:g:q:c:o:h"))!=-1)
	{
		switch(c){
			case 'i': input_ref1=optarg;break;
			case 'I': input_ref2=optarg;break;
			case 's': error_profile=optarg;break;
			case 'd': GC_depth_file=optarg;break;
			case 'l': read_length=atoi(optarg);break;
			case 'x': coverage=strtod(optarg,NULL);break;
			case 'm': insertsize_mean=atoi(optarg);break;
			case 'v': insertsize_sd=atoi(optarg);break;
			case 'e': error_rate=strtod(optarg,NULL);break;
			case 'f': Is_cyclization=atoi(optarg);break;
			case 'g': Is_simulate_GC_bias=atoi(optarg);break;
			case 'q': Is_simulate_quality=atoi(optarg);break;
			case 'c': output_type=atoi(optarg);break;
			case 'o': output_prefix=optarg;break;
			case 'h': Usage();break;
			default: Usage();
		}
	}
}

int main(int argc, char *argv[])
{
	time_t time_start, time_end;
	time_start = time(NULL);
	srand((unsigned)time(NULL));
	
	if (argc==1)
	{
		Usage();
	}
	
	Getopt(argc,argv);
	
	//set insertsize sd default value
	if(insertsize_sd == -1){insertsize_sd = int(insertsize_mean/20);}
		
	if(input_ref1 == ""){cerr<<"Error: there is not default value with option -i, please input reference sequence!"<<endl;exit(-1);}
	if(read_length <= 0){cerr<<"Error: read length should be set bigger than 0, please check option -l !"<<endl;exit(-1);}
	if(coverage <= 0){cerr<<"Error: coverage should be set bigger than 0, please check option -x !"<<endl;exit(-1);}
	if(insertsize_mean < read_length){cerr<<"Error: insertize mean should be set bigger than read_length, please check option -m !"<<endl;exit(-1);}
	if(insertsize_sd < 0){cerr<<"Error: insertsize_sd should be set bigger than 0, please check option -v !"<<endl;exit(-1);}
	if(error_rate != -1 && error_rate < 0 || error_rate >= 1){cerr<<"Error: error_rate should be set between 0 and 1, or set -1 to simulate default error rate according with error profile, please check option -e !"<<endl;exit(-1);}
	if(Is_cyclization != 0 && Is_cyclization != 1){cerr<<"Error: Is_cyclization should be set 0 or 1, please check option -f !"<<endl;exit(-1);}
	if(Is_simulate_GC_bias != 0 && Is_simulate_GC_bias != 1){cerr<<"Error: Is_simulate_GC_bias should be set 0 or 1, please check option -g !"<<endl;exit(-1);}
	if(Is_simulate_quality != 0 && Is_simulate_quality != 1){cerr<<"Error: Is_simulate_quality should be set 0 or 1, please check option -q !"<<endl;exit(-1);}
	if(output_type != 0 && output_type != 1){cerr<<"Error: output_type should be set 0 or 1, please check option -c !"<<endl;exit(-1);}
	
	Simulate_Cycle_num = read_length*2;
	
	//open input file
	igzstream infile;
	igzstream infile2;
	
	//set and open output file
	ofstream log;
	ofstream insert_log;
	ofstream error_log;
	
	//check file
	set_and_check_file(infile, infile2, log, insert_log, error_log);
	
	///////////////////////////////////////////////////////////////////////////
	string exe_path = argv[0]; //program package path
	
	log<<"Start to preview error profile..."<<endl;
	//get dimensions of error profile
	preview_error_profile(exe_path, log);
  log << "Dimensions of error profile:\n";
  log << "       Ref_Base_num: " << Ref_Base_num << endl;
  log << "       Statistical_Cycle_num: " << Statistical_Cycle_num << endl;
  log << "       Seq_Base_num: " << Seq_Base_num << endl;
  log << "       Quality_num: " << Quality_num << endl;
  log <<	"       "<<read_length<<"bp reads total average error rate: "<< Statistical_average_error_rate <<endl;
	
	//initialize simulation matrix
	if(Is_simulate_quality){ 
  	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num*Quality_num
  	simulation_matrix = new double**[Ref_Base_num];
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		simulation_matrix[i] = new double*[Simulate_Cycle_num];
  		for(int j=0; j<Simulate_Cycle_num; j++)
  		{
  			simulation_matrix[i][j] = new double[Seq_Base_num*Quality_num];
  			for(int k=0; k<Seq_Base_num*Quality_num; k++)
  			{
  				simulation_matrix[i][j][k] = 0;
  			}
  		}
  	}
  }else{ //simulate fa read matrix
  	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num
  	simulation_matrix = new double**[Ref_Base_num];
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		simulation_matrix[i] = new double*[Simulate_Cycle_num];
  		for(int j=0; j<Simulate_Cycle_num; j++)
  		{
  			simulation_matrix[i][j] = new double[Seq_Base_num];
  			for(int k=0; k<Seq_Base_num; k++)
  			{
  				simulation_matrix[i][j][k] = 0;
  			}
  		}
  	}
  }
	
	//get the simulation matrix
	load_error_profile(exe_path, log);
	
	//////////////////////////////////////////////////////////////////////////
	//get GC abundance for simulate GC bias
	if(Is_simulate_GC_bias){
		GC_bias_abundance = new double[101];
		for(int i = 0; i <= 100; i++)
		{
			GC_bias_abundance[i] = 0.0;
		}
		load_GC_depth_profile(exe_path, log);
	}
	
	//initialize error position distribution table
	error_pos_distr = new uint64_t[Simulate_Cycle_num+1];
	Q_to_Erate_distr = new double[Simulate_Cycle_num+1];
	for(int i=0; i<=Simulate_Cycle_num; i++)
	{
		error_pos_distr[i] = 0;
		Q_to_Erate_distr[i] = 0.0;
	}
	
	////////////////////////////////////////////////////////////////////////
	//start simulation
	Get_genome(infile,infile2,log);
	
	////////////////////////////////////////////////////////////////////////
//	cerr<<"error_total_num: "<<error_total_num<<endl;
	//ouput error position distribution
	error_log<<"**********Error rate distribution**********"<<endl;
	if(Is_simulate_quality){
		error_log<<"Cycle\tReal_error_rate\tQuality_to_error_rate"<<endl;
  	for(int i=1; i<=Simulate_Cycle_num; i++){
  		error_log<<i<<"\t"<<double(error_pos_distr[i])/double(total_read_pair)<<"\t"<<Q_to_Erate_distr[i]/double(total_read_pair)<<endl;
  		if(i== read_length){error_log<<endl;}
  	}
	}else{
		error_log<<"Cycle\tReal_error_rate"<<endl;
  	for(int i=1; i<=Simulate_Cycle_num; i++){
  		error_log<<i<<"\t"<<double(error_pos_distr[i])/double(total_read_pair)<<endl;
  		if(i== read_length){error_log<<endl;}
  	}
	}
	
	//output insert size distribution
	insert_log<<"**********Insert size distribution************"<<endl
		<<"insert_size_len"<<"\t"<<"number"<<endl;
	map<int, uint64_t>::const_iterator map_it = InsertSize_distr.begin();
	while (map_it != InsertSize_distr.end())
	{
		insert_log<<map_it->first<<"\t"<<map_it->second<<endl;
		//cout<<map_it->second<<endl;
		map_it++;
	}
	
  for(int i=0; i<Ref_Base_num; i++)
  {
  	for(int j=0; j<Simulate_Cycle_num; j++)
  	{
  		delete[] simulation_matrix[i][j];
  	}
  	delete[] simulation_matrix[i];
  }
  delete[] simulation_matrix;
	
	time_end = time(NULL);
	log<<"All done! Run time: "<<time_end-time_start<<"s."<<endl;
	
	return 0;
}

void set_and_check_file(igzstream &infile, igzstream &infile2, ofstream &log, ofstream &insert_log, ofstream &error_log)
{
	//set and open output file
	infile.open(input_ref1.c_str());
	if (!infile)
	{
		cerr<<"Error:unable to open input file:"<<input_ref1<<endl;
		exit(-1);
	}
	
	if(input_ref2!="")
	{
		infile2.open(input_ref2.c_str());
  	if (!infile2)
  	{
  		cerr<<"Error:unable to open input file:"<<input_ref2<<endl;
  		exit(-1);
  	}
	}
	
	string output_file1, output_file2, output_log, output_insert_distr, output_error_distr;
	string infix_name = "_"+boost::lexical_cast <std::string>(read_length)+"_"+boost::lexical_cast <std::string>(insertsize_mean);
	//read file1
	if(Is_simulate_quality){
		output_file1 = output_prefix+infix_name+"_1.fq";
		//read file2
		output_file2 = output_prefix+infix_name+"_2.fq";
	}else{
		output_file1 = output_prefix+infix_name+"_1.fa";
		//read file2
		output_file2 = output_prefix+infix_name+"_2.fa";
	}
	//compress ouput
	if(output_type == 1){
		output_file1+=".gz";
		output_file2+=".gz";
	}
	output_log = output_prefix+infix_name+".log";
	//insert size distribution file
	output_insert_distr = output_prefix+infix_name+".insertsize.distr";
	//error rate distribution file
	output_error_distr = output_prefix+infix_name+".error_rate.distr";
	//open file
  if(!output_type){
  	outfile1.open(output_file1.c_str());
  	outfile2.open(output_file2.c_str());
  }else{
  	gz_outfile1.open(output_file1.c_str());
  	gz_outfile2.open(output_file2.c_str());
  }
  log.open(output_log.c_str());
  insert_log.open(output_insert_distr.c_str());
  error_log.open(output_error_distr.c_str());
	
	//check file
	if(!output_type)
	{
		if (!outfile1 || !outfile2)
		{
			cerr<<"Error:unable to open output file."<<endl;
			exit(1);
		}
	}else{
		if (!gz_outfile1 || !gz_outfile2)
		{
			cerr<<"Error:unable to open output file."<<endl;
			exit(1);
		}
	}
	if(!log){cerr<<"Error:unable to open output *log file."<<endl;exit(1);}
	if(!insert_log){cerr<<"Error:unalbe to open output insertsize distribution file."<<endl;exit(1);}
	if(!error_log){cerr<<"Error:unalbe to open output error rate distribution file."<<endl;exit(1);}
}

void preview_error_profile (string exe_path, ofstream &log)
{
	string matrix_file;
	
	if(error_profile == ""){
  	int index = exe_path.find_last_of('/');
  	if(index == -1){
  		log<<"Error: program path wrong!"<<endl;
  	}
  	else{
  		string directory_path = exe_path.substr(0,index);
  		matrix_file = directory_path + "/statistical_file_package/error_profile/"+ error_profile_name;
  	}
	}else{
		matrix_file = error_profile;
	}
	
  igzstream infile;
  infile.open(matrix_file.c_str());
  if ( ! infile )
	{
		log << "fail to open input file" << matrix_file << endl;
	}
	uint64_t total_count_sum = 0;
	uint64_t total_error_sum = 0;
	uint64_t total_correct_sum = 0;

	string lineStr;
	while (getline( infile, lineStr, '\n' ))
	{ if (lineStr[0] == '#')
		{ if (lineStr[1] == 'D' && lineStr[2] == 'i' && lineStr[3] == 'm')
			{	vector<string> lineVec;
				boost::split(lineVec,lineStr, boost::is_any_of(":,; \t\n"), boost::token_compress_on);
				Ref_Base_num = atoi(lineVec[2].c_str());
				Statistical_Cycle_num = atoi(lineVec[4].c_str());
				//依据error profile判断用户模拟读长是否超出
				if(read_length > Statistical_Cycle_num/2){cerr<<"Error: according to the error profile, program can be simulate "<< Statistical_Cycle_num/2 <<"bp read length at most, please set read length again!"<<endl;exit(-1);}
				Seq_Base_num = atoi(lineVec[6].c_str());
				Quality_num = atoi(lineVec[8].c_str());
			}
			else
			{
				continue;
			}
		}
		else
		{ 
			if(lineStr == ""){continue;}
			vector<string> lineVec;
			boost::split(lineVec,lineStr, boost::is_any_of(" \t\n"), boost::token_compress_on);
			
			char ref_base = lineVec[0][0];
			int current_cycle = atoi(lineVec[1].c_str());
				
			//只统计用户输入读长范围内个数
			if(current_cycle <= read_length || (current_cycle >= Statistical_Cycle_num/2 && current_cycle <= Statistical_Cycle_num/2+read_length)){
    		for(int i = 0; i < Seq_Base_num; i++)
    		{
    			for(int j = 0; j < Quality_num; j++)
    			{
    				string num = lineVec[i * Quality_num + j + 2];
    				uint64_t freqnum = boost::lexical_cast<uint64_t>(num);
  //  				uint64_t freqnum = toUint64_t(num);
    				total_count_sum+=freqnum;
    				if( i == alphabet2[ref_base])  // ACGT  
    				{
    					total_correct_sum+=freqnum;
    				}else{
    					total_error_sum+=freqnum;
    				}
    			}
    		}
  		}
		}
	}
	
	//get error profile average error rate
	Statistical_average_error_rate = double(total_error_sum)/double(total_count_sum);
  
}

void load_GC_depth_profile (string exe_path, ofstream &log)
{
	string depth_file;
	
	if(GC_depth_file == ""){
  	int index = exe_path.find_last_of('/');
  	if(index == -1){
  		log<<"Error: program path wrong!"<<endl;
  	}
  	else{
  		string directory_path = exe_path.substr(0,index);
  		depth_file = directory_path + "/statistical_file_package/GC_depth_profile/"+GC_depth_profile_name;
  	}
	}else{
		depth_file = GC_depth_file;
	}
	
  igzstream infile;
  infile.open(depth_file.c_str());
  if ( ! infile )
	{
		log << "fail to open input file" << depth_file << endl;
	}
	uint64_t total_count_sum = 0;
	uint64_t total_error_sum = 0;

	string lineStr;
	vector<double> GC_ratio_vec;
	vector<double> depth_vec;
	while (getline( infile, lineStr, '\n' ))
	{ if (lineStr[0] == '#' || lineStr == "")
		{ 
			continue;
		}
		else
		{ 
			vector<string> lineVec;
			boost::split(lineVec,lineStr, boost::is_any_of(" \t\n"), boost::token_compress_on);
			GC_ratio_vec.push_back(boost::lexical_cast<double>(lineVec[0]));
			depth_vec.push_back(boost::lexical_cast<double>(lineVec[1]));
		}
	}
	
	//find max depth
	double max_depth = 0;
	for(int i = 0; i < depth_vec.size(); i++)
	{
		if(depth_vec[i] > max_depth){
			max_depth = depth_vec[i];
		}
	}
	
	//convert to GC abundance
	for(int i = 1; i < GC_ratio_vec.size(); i++)
	{
		for(int j = int(GC_ratio_vec[i-1]); j < int(GC_ratio_vec[i]); j++)
		{
			GC_bias_abundance[j] = depth_vec[i-1]/max_depth;
  	}
  }
  for(int i = int(GC_ratio_vec[GC_ratio_vec.size()-1]); i <=100; i++)
  {
  	GC_bias_abundance[i] = depth_vec[depth_vec.size()-1]/max_depth;
  }
  
  /*
  for(int i = 0; i <=100; i++)
  {
  	cerr<<"GC%:"<<i<<"\t"<<GC_bias_abundance[i]<<endl;
  }
  */
}

//read in quality distribution file and get the quality distribution table.
void load_error_profile(string exe_path, ofstream &log)
{
	string matrix_file;
	if(error_profile == ""){
  	int index = exe_path.find_last_of('/');
  	if(index == -1){
  		log<<"Error: program path wrong!"<<endl;
  	}
  	else{
  		string directory_path = exe_path.substr(0,index);
  		matrix_file = directory_path + "/statistical_file_package/error_profile/" + error_profile_name;
  	}
	}else{
		matrix_file = error_profile;
	}

	igzstream MatrixFile;
	MatrixFile.open(matrix_file.c_str());
	if ( ! MatrixFile )
	{	log << "fail to open input file " << matrix_file <<", make sure statistics file place in program directory!"<< endl;
		exit(-1);
	}
	
	string str_line;
	log <<"Start to construct simulation matrix..."<<endl
		<<"Reading file: "<<matrix_file<<endl;
	
	
	//用户输入的平均错误率与统计文件的平均错误率比例值
	double E_ratio = 0;
	if(error_rate == -1){
		E_ratio = 1;
	}else{
		E_ratio = error_rate/Statistical_average_error_rate;
	}
	
	int simulate_cycle = 0;
	while(getline(MatrixFile, str_line, '\n'))
	{
		if(str_line[0] == '#' || str_line == ""){continue;}

		vector<string> str_line_tokens;
		boost::split(str_line_tokens,str_line, boost::is_any_of(" \t\n"), boost::token_compress_on);
		char ref_base = str_line_tokens[0][0];
		int current_cycle = atoi(str_line_tokens[1].c_str());
		
		if(current_cycle == 1){simulate_cycle = 0;}
		if(current_cycle <= read_length || (current_cycle > Statistical_Cycle_num/2 && current_cycle <= Statistical_Cycle_num/2+read_length))
		{
			//用户输入的模拟cycle数 Simulate_Cycle_num
			simulate_cycle++;
  		uint64_t error_sum = 0;
  		uint64_t count_sum = 0;
  		uint64_t correct_sum = 0;
  		//获取当前Cycle错误率
  		for(int i = 0; i < Seq_Base_num; i++)
  		{
  			for(int j = 0; j < Quality_num; j++)
  			{
  				string num = str_line_tokens[i * Quality_num + j + 2];
  				uint64_t current_num = boost::lexical_cast<uint64_t>(num);
  				count_sum+=current_num;
  				if( i == alphabet2[ref_base])  // ACGT  
  				{
  					correct_sum+=current_num;
  				}else{
  					error_sum+=current_num;
  				}
  			}
  		}
  		double this_cycle_error_rate = double(error_sum)/double(count_sum);
  		
  		if(Is_simulate_quality)
  		{
    		//按照错误率等比例求出用户输入错误率下的数据矩阵
    		for(int i = 0; i < Seq_Base_num; i++)
    		{
    			for(int j = 0; j < Quality_num; j++)
    			{
    				string num = str_line_tokens[i * Quality_num + j + 2];
    				uint64_t current_num = boost::lexical_cast<uint64_t>(num);
    				count_sum+=current_num;
    				if( i == alphabet2[ref_base])  // ACGT  
    				{
    					//正确个数需要按照(1-this_cycle_error_rate*E/e)/(1-this_cycle_error_rate) 其中E为用户输入的平均错误率，e表示该统计文件的平均错误率
    					simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i*Quality_num+j] = current_num*(1-this_cycle_error_rate*E_ratio)/(1-this_cycle_error_rate);
    					//cerr<<simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i*Quality_num+j]<<" ";
    				}else{
    					//错误个数等比例转换
    					simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i*Quality_num+j] = current_num*E_ratio;
    					//cerr<<simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i*Quality_num+j]<<" ";
    				}
    			}
    		}
    		//cerr << endl;
    
    		//求出数据的累积比率
    		double sum = 0;
    		for(int i = 0; i < Seq_Base_num*Quality_num; i++)
    		{
    			sum += simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i];
    		}
    		//cerr<<sum<<endl;
    		if(sum == 0){
    			for(int i = 0; i < Seq_Base_num*Quality_num; i++)
    			{
    				simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i] = 0;
    			}	
    		}else{
    			double accumulate_value = 0;
    			for(int i = 0; i < Seq_Base_num*Quality_num; i++)
    			{
    				accumulate_value += simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i];
    				simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i] = accumulate_value/sum;
    			}	
    		}
  		}else{
    		//按照错误率等比例求出用户输入错误率下的数据矩阵
    		for(int i = 0; i < Seq_Base_num; i++)
    		{
    			for(int j = 0; j < Quality_num; j++)
    			{
    				string num = str_line_tokens[i * Quality_num + j + 2];
    				uint64_t current_num = boost::lexical_cast<uint64_t>(num);
    				count_sum+=current_num;
    				if( i == alphabet2[ref_base])  // ACGT  
    				{
    					//正确个数需要按照(1-this_cycle_error_rate*E/e)/(1-this_cycle_error_rate) 其中E为用户输入的平均错误率，e表示该统计文件的平均错误率
    					simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i] += current_num*(1-this_cycle_error_rate*E_ratio)/(1-this_cycle_error_rate);
    					//cerr<<simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i*Quality_num+j]<<" ";
    				}else{
    					//错误个数等比例转换
    					simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i] += current_num*E_ratio;
    					//cerr<<simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i*Quality_num+j]<<" ";
    				}
    			}
    		}
   		  //cerr << endl;
    
    		//求出数据的累积比率
    		double sum = 0;
    		for(int i = 0; i < Seq_Base_num; i++)
    		{
    			sum += simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i];
    		}
    		//cerr<<sum<<endl;
    		if(sum == 0){
    			for(int i = 0; i < Seq_Base_num; i++)
    			{
    				simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i] = 0;
    			}	
    		}else{
    			double accumulate_value = 0;
    			for(int i = 0; i < Seq_Base_num; i++)
    			{
    				accumulate_value += simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i];
    				simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i] = accumulate_value/sum;
    				//cerr<<simulation_matrix[alphabet2[ref_base]][simulate_cycle-1][i]<<" ";
    			}	
    		}
  		}
		}
		//cerr << endl;
		
	}
  
  log <<"Finish construct simulation matrix"<<endl;
}

void Get_genome(igzstream &inf,igzstream &inf2,ofstream &log1){
	string line,line2,id,id_line,seq,seq2;
	uint64_t readINgenome=0;

	while (getline(inf,line,'\n'))
	{
		if (line[0]=='>')
		{
			if (seq!="")
			{	
				//heterozygous SNP and heterozygous indel exists is diploid
				if(input_ref2 != ""){
					while(getline(inf2,line2,'\n'))
					{
						if(line2[0] == '>')
						{
							if(seq2!="")
							{
//								cerr <<seq2<<endl;
        				log1<<"Have finished reading scaffold "<<id<<endl;
        				readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,log1,readINgenome);
        				seq="";
        				seq2="";
        				break;
							}
						}else{
							seq2+=line2;
						}
					}
				}else{
					log1<<"Have finished reading scaffold "<<id<<endl;

					readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,log1,readINgenome);
					seq="";
				}
			}
			id_line = line;
			line.erase(0,1);
//			id=line;
			int pos=line.find(" ");
			line=line.substr(0,pos);
			id=line;
		}else{
			seq+=line;
		}		
	}
	log1<<"Have finished reading scaffold "<<id<<endl;
	if(input_ref2 != ""){
		while(getline(inf2,line2,'\n'))
		{
			if(line2[0] == '>'){continue;}
			seq2+=line2;
		}
//		cerr<<seq2<<endl;
	}
	readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,log1,readINgenome);
}

uint64_t contral_reads_quantity(string id_line,string id,string &sequence,string &sequence2,ofstream &log2,uint64_t read_genome)
{
	uint64_t readonchr=0;
	if (sequence.size()<insertsize_mean)
	{
		return 0;
	}
	//convert lower case to upper case 
	to_upper(sequence);

	uint64_t sequence_length=sequence.size();
	uint64_t reads_pair_num=0;
	
	if (input_ref2 != "")
	{
		reads_pair_num=(uint64_t)(sequence_length*coverage/read_length/2/2);
	}else{
		reads_pair_num=(uint64_t)(sequence_length*coverage/read_length/2);
	}
	total_read_pair = total_read_pair + (uint64_t)(sequence_length*coverage/read_length/2);
	
	if(Is_simulate_quality){
		readonchr=simulate_fq_reads(sequence,sequence_length,reads_pair_num,
			id,log2,read_genome);
	}else{
		readonchr=simulate_fa_reads(sequence,sequence_length,reads_pair_num,
			id,log2,read_genome);
	}

	if (input_ref2 != "") 
	{
		sequence_length=sequence2.size();
		reads_pair_num=(uint64_t)(sequence_length*coverage/read_length/2/2);

		uint64_t readonchr2=read_genome+readonchr;
		if(Is_simulate_quality){
			readonchr+=simulate_fq_reads(sequence2,sequence_length,reads_pair_num,
				id,log2,readonchr2);
		}else{
			readonchr+=simulate_fa_reads(sequence2,sequence_length,reads_pair_num,
				id,log2,readonchr2);
		}
	}
	return readonchr;
}


uint64_t simulate_fq_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, ofstream &log3, uint64_t reads_all)
{
	int whether_check_seq = 0; 
	if(!check_seq(seq)){
		whether_check_seq = 1;
	}
	
	uint64_t reads_count=0;
	log3<<"Begin to output reads"<<endl;
	for(uint64_t pair_count=0; pair_count < rd_pair; pair_count++)
	{
		//simulate insertsize
		int insertsize = simulate_insertsize(insertsize_mean,insertsize_sd);
		if (insertsize<read_length){pair_count--;continue;}
		if (seqlen<insertsize){return reads_count;}
		uint64_t N = 1000000000000;
		uint64_t pos = (uint64_t)(((uint64_t)((double)rand() / double(RAND_MAX) * N)) % seqlen);
		if (pos+insertsize>seqlen){pair_count--;continue;}
			
		//get insert seq
		string sub_str=seq.substr(pos,insertsize);
	
		//get read1 and read2
		string read1=sub_str.substr(0,read_length);
		string read2=sub_str.substr(insertsize-read_length,read_length);
		
		//check whether contain 'N' or nonbase char
		if(whether_check_seq && (!check_seq(read1) || !check_seq(read2))){
			pair_count--;
			continue;
		}
		
		//simulate GC bias
		if(Is_simulate_GC_bias){
			string check_seq = read1+read2;
			if(simulate_GC_bias(check_seq,GC_bias_abundance)){pair_count--;continue;}
		}
		
		//insertsize statistics
		if(InsertSize_distr[insertsize]>0)
		{
			InsertSize_distr[insertsize]++;
		}else{
			InsertSize_distr[insertsize] = 1;
		}
		
		reads_count++;
		
		if ( Is_cyclization == 1 )
		{
			read1=reversecomplementary(read1);
		}else if (insertsize_mean>0)
		{
			read2=reversecomplementary(read2);
		}else{
			cout<<"Error:insertsize mean is smaller than 0"<<endl;
			exit(-1);
		}
		
		int selection=int(rand()%2); //随机选择输出到文件1还是文件2
		
		string output_read1, output_read2, output_quality_seq1, output_quality_seq2;
		
		//simulate read1
		vector<int> error_pos1;
		vector<char> raw_base1;
		for(int i = 0; i < read_length; i++)
		{
			double num=double(rand())/double(RAND_MAX);
			char ref_base = read1[i];
			int cycle;
			if(selection == 0){
				cycle = i;
			}else{
				cycle = i+Simulate_Cycle_num/2;
			}
			
			int location = search_location(simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num*Quality_num, num);
			int call_base_num = int(location/Quality_num);
			char call_base = Bases[call_base_num];
			if(ref_base != call_base){
				if(selection == 0){
					error_pos_distr[i+1]++;
				}else{
					error_pos_distr[i+1+read_length]++;
				}
				error_pos1.push_back(i);
				raw_base1.push_back(ref_base);
			}
			output_read1.push_back(call_base);
			int Qscore = location%Quality_num;
			char quality_value = Qscore + 64;  //
			output_quality_seq1.push_back(quality_value);
			if(selection == 0){
				Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
			}else{
				Q_to_Erate_distr[i+1+read_length]+= pow(10,double(Qscore)/double(-10));
			}
		}
		
		//simulate read2
		vector<int> error_pos2;
		vector<char> raw_base2;
		for(int i = 0; i < read_length; i++)
		{
			double num=double(rand())/double(RAND_MAX);
			char ref_base = read2[i];
			int cycle;
			if(selection == 0){
				cycle = i+Simulate_Cycle_num/2;
			}else{
				cycle = i;
			}
				
			int location = search_location(simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num*Quality_num, num);
			int call_base_num = int(location/Quality_num);
			char call_base = Bases[call_base_num];
			if(ref_base != call_base){
				if(selection == 0){
					error_pos_distr[i+1+read_length]++;
				}else{
					error_pos_distr[i+1]++;
				}
				error_pos2.push_back(i);
				raw_base2.push_back(ref_base);
			}
			output_read2.push_back(call_base);
			int Qscore = location%Quality_num;
			char quality_value = Qscore + 64;  //
			output_quality_seq2.push_back(quality_value);
			if(selection == 0){
				Q_to_Erate_distr[i+1+read_length]+= pow(10,double(Qscore)/double(-10));
			}else{
				Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
			}
		}
		
		//output simulate reads
		if (reads_count%10000==0)
		{
			log3<<"Output "<<reads_count<<" pair reads"<<endl;
		}
		
  	//output read file
		if(selection == 0){
			//output read file1
			//text output
			if(!output_type){
  			outfile1<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			outfile1<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file2
  			outfile2<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			outfile2<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
  		}else{//*.gz output
				gz_outfile1<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				gz_outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			gz_outfile1<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file2
				gz_outfile2<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				gz_outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			gz_outfile2<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
  		}
		
		}else{
			
			//output read file2
			//text output
			if(!output_type){
				outfile2<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			outfile2<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file1
				outfile1<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			outfile1<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
			}else{//*.gz output
				gz_outfile2<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				gz_outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			gz_outfile2<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file1
				gz_outfile1<<"@read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				gz_outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			gz_outfile1<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
			}
		}
	}
	log3<<"Finish output reads"<<endl;
	return reads_count;
}


uint64_t simulate_fa_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, ofstream &log3, uint64_t reads_all)
{
	int whether_check_seq = 0; 
	if(!check_seq(seq)){
		whether_check_seq = 1;
	}
	
	uint64_t reads_count=0;
	log3<<"Begin to output reads"<<endl;
	for(uint64_t pair_count=0; pair_count < rd_pair; pair_count++)
	{
		//simulate insertsize
		int insertsize = simulate_insertsize(insertsize_mean,insertsize_sd);
		if (insertsize<read_length){pair_count--;continue;}
		if (seqlen<insertsize){return reads_count;}
		uint64_t N = 1000000000000;
		uint64_t pos = (uint64_t)(((uint64_t)((double)rand() / double(RAND_MAX) * N)) % seqlen);
		if (pos+insertsize>seqlen){pair_count--;continue;}
			
		//get insert seq
		string sub_str=seq.substr(pos,insertsize);
		
		//get read1 and read2
		string read1=sub_str.substr(0,read_length);
		string read2=sub_str.substr(insertsize-read_length,read_length);

		//check whether contain 'N' or nonbase char
		if(whether_check_seq && (!check_seq(read1) || !check_seq(read2))){
			pair_count--;
			continue;
		}
		
		//simulate GC bias
		if(Is_simulate_GC_bias){
			string check_seq = read1+read2;
			if(simulate_GC_bias(check_seq,GC_bias_abundance)){pair_count--;continue;}
		}
		
		//insertsize statistics
		if(InsertSize_distr[insertsize]>0)
		{
			InsertSize_distr[insertsize]++;
		}else{
			InsertSize_distr[insertsize] = 1;
		}
		
		reads_count++;
		
		if ( Is_cyclization == 1 )
		{
			read1=reversecomplementary(read1);
		}else if (insertsize_mean>0)
		{
			read2=reversecomplementary(read2);
		}else{
			cout<<"Error:insertsize mean is smaller than 0"<<endl;
			exit(-1);
		}
		
		int selection=int(rand()%2); //随机选择输出到文件1还是文件2
		
		string output_read1, output_read2;
		
		//simulate read1
		vector<int> error_pos1;
		vector<char> raw_base1;
		for(int i = 0; i < read_length; i++)
		{
			double num=double(rand())/double(RAND_MAX);
			char ref_base = read1[i];
			int cycle;
			if(selection == 0){
				cycle = i;
			}else{
				cycle = i+Simulate_Cycle_num/2;
			}
			
			int location = search_location(simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num, num);
			char call_base = Bases[location];
			if(ref_base != call_base){
				if(selection == 0){
					error_pos_distr[i+1]++;
				}else{
					error_pos_distr[i+1+read_length]++;
				}
				error_pos1.push_back(i);
				raw_base1.push_back(ref_base);
			}
			output_read1.push_back(call_base);
		}
		
		//simulate read2
		vector<int> error_pos2;
		vector<char> raw_base2;
		for(int i = 0; i < read_length; i++)
		{
			double num=double(rand())/double(RAND_MAX);
			char ref_base = read2[i];
			int cycle;
			if(selection == 0){
				cycle = i+Simulate_Cycle_num/2;
			}else{
				cycle = i;
			}
			int location = search_location(simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num, num);
			char call_base = Bases[location];
			if(ref_base != call_base){
				if(selection == 0){
					error_pos_distr[i+1+read_length]++;
				}else{
					error_pos_distr[i+1]++;
				}
				error_pos2.push_back(i);
				raw_base2.push_back(ref_base);
			}
			output_read2.push_back(call_base);
		}
		
		//output simulate reads
		if (reads_count%10000==0)
		{
			log3<<"Output "<<reads_count<<" pair reads"<<endl;
		}
		
  	//output read file
		if(selection == 0){
			//output read file1
			//text output
			if(!output_type){

  			outfile1<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			outfile1<<endl<<output_read1<<endl;
    		
    		//output read file2
  			outfile2<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			outfile2<<endl<<output_read2<<endl;
  		}else{//*.gz output
				gz_outfile1<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				gz_outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			gz_outfile1<<endl<<output_read1<<endl;
    		
    		//output read file2
				gz_outfile2<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				gz_outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			gz_outfile2<<endl<<output_read2<<endl;
  		}
		
		}else{
			//output read file2
			//text output
			if(!output_type){
				outfile2<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			outfile2<<endl<<output_read1<<endl;
    		
    		//output read file1
				outfile1<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			outfile1<<endl<<output_read2<<endl;
  			
			}else{//*.gz output
				gz_outfile2<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				gz_outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			gz_outfile2<<endl<<output_read1<<endl;
    		
    		//output read file1
				gz_outfile1<<">read_"<<insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-read_length+1<<" "<<read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				gz_outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			gz_outfile1<<endl<<output_read2<<endl;
			}
		}

	}
	log3<<"Finish output reads"<<endl;
	return reads_count;
}
