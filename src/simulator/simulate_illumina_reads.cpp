#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <math.h>
#include <map>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>
#include "gzstream.h"
#include "simulate.h"
#include "load_file.h"
#include "global.h"

using namespace std;
using namespace boost; 

//parameter variable
PARAMETER InputParameter ={100,500,-1,0,1,1,1,64,1,40,-1,"","","","","Illumina"};

int Ref_Base_num = 0;  //ATCG: 4
int Statistical_Cycle_num = 0; //the cycle number in Base-calling profile
int Seq_Base_num = 0;  //ATCG: 4
int Quality_num = 0;  //the quality score number in Base-calling profile
int Simulate_Cycle_num = 0; //the cycle number of simulation
double Statistical_average_error_rate = 0; //the average error rate in Base-calling profile

ogzstream Gz_outfile1; 
ogzstream Gz_outfile2;
ofstream Outfile1;
ofstream Outfile2;

double*** First_cycle_matrix = NULL;
double*** Simulation_matrix2 = NULL;
double**** Simulation_matrix1 = NULL;  //for call base and quality simulation
double*** Simulation_matrix = NULL; //for simulate fasta
double* GC_bias_abundance = NULL;  //for GC bias simulation 
map<int,uint64_t> InsertSize_distr; //record the insert size distribution 
uint64_t* Error_pos_distr = NULL; //record the error position distribution
double* Q_to_Erate_distr = NULL; //record quality score to error rate distribution
uint64_t Total_read_pair = 0; 

//get genome sequence and start to simulate read 
void Get_genome(igzstream &inf,igzstream &inf2);
//contral the quantity of simulate reads for each chromosome one by one
uint64_t contral_reads_quantity(string id_line,string id,string &sequ,string &sequ2,uint64_t read_genome);
//simulate fastq reads
uint64_t simulate_fq_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, uint64_t reads_all);
//simulate fasta reads
uint64_t simulate_fa_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, uint64_t reads_all);

const char *VERSION="1.0";
const char *AUTHOR="BGI-Shenzhen";
const char *CONTACT1="yuanjianying@genomics.org.cn";
const char *CONTACT2="shiyujian@genomics.org.cn";

void Usage(){
	cout<<"\nDescription:"<<endl;
	cout<<"   It is a program for simulating Illumina PE reads, with a series of characters generate by illumina ";
	cout<<"sequencing machine, such as insertsize distribution, sequencing error, quality score and GC bias. ";
	cout<<"User should set the value of insertsize_mean and insertsize_sd, they are the mean value and standard ";
	cout<<"deviation of the normal distribution that used as the model function when simulating insertsize ";
	cout<<"distribution, usually we set the insertsize_sd to be 1/20 of the insertsize_mean. The normal distribution ";
	cout<<"function model we used in this program is f(x)=1/σ/sqrt(2*pi)*exp((x-μ)**2 / (2*σ**2)), and the insertsize ";
	cout<<"distribution is simulated by Box-muller method. ";
	cout<<"This program simulates Illumina sequencing error, quality score and GC bias according to the empirical distribution profile. ";
	cout<<"User can set the path of profile or using the default file in this program package, which is generated by large real sequencing data. ";
	cout<<"If you want to simulate diploid(heterozygosis SNP, heterozygosis Indel and structural variation) reads, you should input two ";
	cout<<"reference genome sequence, you can get the another diploid genome sequence by the program \"simulate_diploid_genome\", but ";
	cout<<"remember that heterozygosis SNP rate and heterozygosis Indel rate is only exists in diploid. ";
	cout<<"At last, you should set another several parameters, read length, coverage of reads, input sequence, ";
	cout<<"output prefix and so on, the option -i must be set, because there is no default value."<<endl;
	cout<<endl<<"Program: simulate_illumina_reads"<<endl;
	cout<<"\tVersion: "<<VERSION<<endl;
	cout<<"\tAuthor: "<<AUTHOR<<endl;
	cout<<"\tContact: "<<CONTACT1<<" "<<CONTACT2<<endl;
	cout<<endl<<"Usage:\tsimulate_illumina_reads [options]"<<endl;
	cout<<"\t-i  <string>  input_ref1,input reference genome sequence *.fa/*.fa.gz, no default vaule"<<endl;
	cout<<"\t-I  <string>  input_ref2,for diploid genome, input another reference genome sequence which was generated by program \"simulate_snp_indel_seq\""<<endl;
	cout<<"\t-s  <string>  Base-calling profile,input Base-calling profile for simulating sequencing error and quality score,default: (exe_path)/Profiles/Base-calling_profile/hum20110701.bwanosnp.count.matrix"<<endl;
	cout<<"\t-d  <string>  GC-depth profile,input GC-depth file for simulating GC bias, the default GC bias profiles are determined based on the twice of read length"<<endl;
	cout<<"\t-l  <int>     read_len,set length of read,read1 and read2 have the same length,default:"<<InputParameter.Read_length<<endl;
	cout<<"\t-x  <double>  coverage,set the sequencing coverage(sometimes called depth),default:"<<InputParameter.Coverage<<endl;
	cout<<"\t-m  <int>     insertsize_mean,set the average value of insert size,default:"<<InputParameter.Insertsize_mean<<endl;
	cout<<"\t-v  <int>     insertsize_sd,set the standard deviation of insert sizes, default:insertsize_mean/20"<<endl;
//	cout<<"\t-e  <double>  error_rate,set the average error rate over all cycles,default=average error rate of Base-calling profile"<<endl;
	cout<<"\t-g  <int>     whether simulate GC bias, 0:no, 1:yes, default:"<<InputParameter.Is_simulate_GC_bias<<endl;
	cout<<"\t-q  <int>     whether simulate quality value, 0:no(fasta), 1:yes(fastq), default:"<<InputParameter.Is_simulate_quality<<endl;
	cout<<"\t-M  <int>     whether simulate quality value by Quality-transition mode, 0:no, 1:yes, default:"<<InputParameter.Q_Mode<<endl;
	cout<<"\t-Q  <int>     Quality value ascii shift, generally 64 or 33 for Illumina data, default:"<<InputParameter.Q_shift<<endl;
	cout<<"\t-f  <int>     whether cyclize insert sequence(influence on PE-reads direction) 0: read1-forward read2-reverse, 1: read1-reverse read2-forward, default:"<<InputParameter.Is_cyclization<<endl;
	cout<<"\t-c  <int>     set output file type, 0:text, 1:*.gz, default:"<<InputParameter.Output_type<<endl;
	cout<<"\t-o  <string>  output,output file prefix default:"<<InputParameter.Output_prefix<<endl;
	cout<<"\t-h            output help infomation."<<endl;
	cout<<endl<<"Example:"<<endl;
	cout<<"\t1. ./simulate_illumina_reads -i ref_sequence.fa"<<endl;
	cout<<"\t  Every parameter use the default value."<<endl;
	cout<<"\t2. ./simulate_illumina_reads -i ref_sequence.fa -l 100 -x 20 -o human_500_100"<<endl;
	cout<<"\t  Just set read length and coverage you needed."<<endl;
	cout<<"\t3. ./simulate_illumina_reads -i ref_sequence.fa -o human -m 600 -v 30 -e 0.01"<<endl;
	cout<<"\t  Set insertsize distribution and error rate."<<endl;
	cout<<"\t4. ./simulate_illumina_reads -i ref_sequence.fa -I ref_seq.snp.indel.invertion.fa.gz -o human "<<endl;
	cout<<"\t  The genome is diploid and you want to produce heterozygosis SNPs  heterozygosis Indels in reads, "<<endl;
	cout<<"\t  the -I input file was generated by program \"simulate_diploid_genome\"."<<endl;
	cout<<"\t5. ./simulate_illumina_reads -i ref_sequence.fa -g 0 -m 50000 -f 1 -c 0 -o human "<<endl;
	cout<<"\t  Set simulate no GCbias and cyclize the large insert-size library, output file is text format."<<endl;
	cout<<"\t6. ./simulate_illumina_reads -i ref_sequence.fa -q 0 -o human "<<endl;
	cout<<"\t  Set simulate quality value, the ouput is in *.fa format."<<endl;
	exit(-1);
}

void Getopt(int argc,char *argv[]){
	int c;
	while ((c=getopt(argc,argv,"i:I:s:d:l:x:m:v:e:f:g:q:M:Q:c:o:h"))!=-1)
	{
		switch(c){
			case 'i': InputParameter.Input_ref1=optarg;break;
			case 'I': InputParameter.Input_ref2=optarg;break;
			case 's': InputParameter.BaseCalling_profile=optarg;break;
			case 'd': InputParameter.GC_depth_profile=optarg;break;
			case 'l': InputParameter.Read_length=atoi(optarg);break;
			case 'x': InputParameter.Coverage=strtod(optarg,NULL);break;
			case 'm': InputParameter.Insertsize_mean=atoi(optarg);break;
			case 'v': InputParameter.Insertsize_sd=atoi(optarg);break;
//			case 'e': InputParameter.Error_rate=strtod(optarg,NULL);break;
			case 'f': InputParameter.Is_cyclization=atoi(optarg);break;
			case 'g': InputParameter.Is_simulate_GC_bias=atoi(optarg);break;
			case 'q': InputParameter.Is_simulate_quality=atoi(optarg);break;
			case 'M': InputParameter.Q_Mode=atoi(optarg);break;
			case 'Q': InputParameter.Q_shift=atoi(optarg);break;
			case 'c': InputParameter.Output_type=atoi(optarg);break;
			case 'o': InputParameter.Output_prefix=optarg;break;
			case 'h': Usage();break;
			default: Usage();
		}
	}
}

int main(int argc, char *argv[])
{
	time_t time_start, time_end;
	time_start = time(NULL);
	srand((unsigned)time(NULL));
	
	if (argc==1)
	{
		Usage();
	}
	
	Getopt(argc,argv);
	
	//set insertsize sd default value
	if(InputParameter.Insertsize_sd == -1){InputParameter.Insertsize_sd = int(InputParameter.Insertsize_mean/20);}
	//check parameter
	if(InputParameter.Input_ref1 == ""){cerr<<"Error: there is not default value with option -i, please input reference sequence!"<<endl;exit(-1);}
	if(InputParameter.Read_length <= 0){cerr<<"Error: read length should be set bigger than 0, please check option -l !"<<endl;exit(-1);}
	if(InputParameter.Coverage <= 0){cerr<<"Error: coverage should be set bigger than 0, please check option -x !"<<endl;exit(-1);}
	if(InputParameter.Insertsize_mean < InputParameter.Read_length){cerr<<"Error: insertize mean should be set bigger than read_length, please check option -m !"<<endl;exit(-1);}
	if(InputParameter.Insertsize_sd < 0){cerr<<"Error: insertsize_sd should be set bigger than 0, please check option -v !"<<endl;exit(-1);}
	if(InputParameter.Error_rate != -1 && InputParameter.Error_rate < 0 || InputParameter.Error_rate >= 1){cerr<<"Error: error_rate should be set between 0 and 1, or set -1 to simulate default error rate according with error profile, please check option -e !"<<endl;exit(-1);}
	if(InputParameter.Is_cyclization != 0 && InputParameter.Is_cyclization != 1){cerr<<"Error: Is_cyclization should be set 0 or 1, please check option -f !"<<endl;exit(-1);}
	if(InputParameter.Is_simulate_GC_bias != 0 && InputParameter.Is_simulate_GC_bias != 1){cerr<<"Error: Is_simulate_GC_bias should be set 0 or 1, please check option -g !"<<endl;exit(-1);}
	if(InputParameter.Is_simulate_quality != 0 && InputParameter.Is_simulate_quality != 1){cerr<<"Error: Is_simulate_quality should be set 0 or 1, please check option -q !"<<endl;exit(-1);}
	if(InputParameter.Q_Mode != 0 && InputParameter.Q_Mode != 1){cerr<<"Error: Q_Mode should be set 0 or 1, please check option -M !"<<endl;exit(-1);}
	if(InputParameter.Output_type != 0 && InputParameter.Output_type != 1){cerr<<"Error: output_type should be set 0 or 1, please check option -c !"<<endl;exit(-1);}
	
	//set the simulate cycle number
	Simulate_Cycle_num = InputParameter.Read_length*2;
	//initialize error position distribution table
	Error_pos_distr = new uint64_t[Simulate_Cycle_num+1];
	Q_to_Erate_distr = new double[Simulate_Cycle_num+1];
	for(int i=0; i<=Simulate_Cycle_num; i++)
	{
		Error_pos_distr[i] = 0;
		Q_to_Erate_distr[i] = 0.0;
	}
	
	//input file
	igzstream infile; 
	igzstream infile2;
	//output file
	ofstream insert_log;
	ofstream error_log;
	//check and open file
	set_and_check_file( InputParameter, infile, infile2, Outfile1,	Outfile2, Gz_outfile1, Gz_outfile2, insert_log, error_log);
	
	
	////////////////////Load error profile///////////////////////
	
	string exe_path = argv[0]; //program package path
	
	cerr<<"Start to preview error profile..."<<endl;
	//get dimensions of error profile  
	preview_BaseCalling_profile (InputParameter, exe_path, Ref_Base_num, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate);
  cerr << "Dimensions of error profile:\n";
  cerr << "       Ref_Base_num: " << Ref_Base_num << endl;
  cerr << "       Statistical_Cycle_num: " << Statistical_Cycle_num << endl;
  cerr << "       Seq_Base_num: " << Seq_Base_num << endl;
  cerr << "       Quality_num: " << Quality_num << endl;
  cerr <<	"       "<<InputParameter.Read_length<<"bp reads total average error rate: "<< Statistical_average_error_rate <<endl;
	
	//initialize simulation matrix
	if(InputParameter.Is_simulate_quality && InputParameter.Q_Mode == 1){ 
  	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num*Quality_num
  	First_cycle_matrix = new double**[Ref_Base_num];
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		First_cycle_matrix[i] = new double*[2];
  		for(int j=0; j<2; j++)
  		{
  			First_cycle_matrix[i][j] = new double[Seq_Base_num*Quality_num];
  			for(int k=0; k<Seq_Base_num*Quality_num; k++)
  			{
  				First_cycle_matrix[i][j][k] = 0;
  			}
  		}
  	}

  	Simulation_matrix1 = new double***[Ref_Base_num];
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		Simulation_matrix1[i] = new double**[Simulate_Cycle_num];
  		for(int j=0; j<Simulate_Cycle_num; j++)
  		{
  			Simulation_matrix1[i][j] = new double*[Quality_num];
  			for(int k=0; k<Quality_num; k++)
  			{
  				Simulation_matrix1[i][j][k] = new double[Seq_Base_num];
  				for(int l=0; l<Seq_Base_num; l++)
  				{
  					Simulation_matrix1[i][j][k][l] = 0;
  				}
  			}
  		}
  	}
  	
		Simulation_matrix2 = new double**[Simulate_Cycle_num];
		for(int i=0; i<Simulate_Cycle_num; i++)
		{
			Simulation_matrix2[i] = new double*[Quality_num];
			for(int j=0; j<Quality_num; j++)
			{
  			Simulation_matrix2[i][j] = new double[Quality_num];
  			for(int k=0; k<Quality_num; k++)
  			{
  				Simulation_matrix2[i][j][k] = 0;
  			}
			}
		}
  }else{ 
  	if(InputParameter.Is_simulate_quality){
    	//simulate fq read matrix
    	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num*Quality_num
    	Simulation_matrix = new double**[Ref_Base_num];
    	for(int i=0; i<Ref_Base_num; i++)
    	{
    		Simulation_matrix[i] = new double*[Simulate_Cycle_num];
    		for(int j=0; j<Simulate_Cycle_num; j++)
    		{
    			Simulation_matrix[i][j] = new double[Seq_Base_num*Quality_num];
    			for(int k=0; k<Seq_Base_num*Quality_num; k++)
    			{
    				Simulation_matrix[i][j][k] = 0;
    			}
    		}
    	}
  	}else{
    	//simulate fa read matrix
    	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num
    	Simulation_matrix = new double**[Ref_Base_num];
    	for(int i=0; i<Ref_Base_num; i++)
    	{
    		Simulation_matrix[i] = new double*[Simulate_Cycle_num];
    		for(int j=0; j<Simulate_Cycle_num; j++)
    		{
    			Simulation_matrix[i][j] = new double[Seq_Base_num];
    			for(int k=0; k<Seq_Base_num; k++)
    			{
    				Simulation_matrix[i][j][k] = 0;
    			}
    		}
    	}
  	}
  }
	
	//get the simulation matrix
	if(InputParameter.Is_simulate_quality && InputParameter.Q_Mode == 1){
		load_BaseCalling_profile(InputParameter, exe_path, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix1, First_cycle_matrix);
		load_BaseCalling_profile(InputParameter, exe_path, Statistical_Cycle_num, Ref_Base_num, Simulate_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix2);
	}else{
		load_BaseCalling_profile(InputParameter, exe_path, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix);
	}
	///////////////////////////load GC bias profile///////////////////////////////
	
	//get GC abundance for simulate GC bias
	if(InputParameter.Is_simulate_GC_bias){
		GC_bias_abundance = new double[101];
		for(int i = 0; i <= 100; i++)
		{
			GC_bias_abundance[i] = 0.0;
		}
		load_GC_depth_profile (InputParameter, exe_path, GC_bias_abundance);
	}
	
	
	///////////////////////////get genome seq and start to simulate reads/////////////////////////////
	
	//start simulation
	Get_genome(infile,infile2);
	
	
	/////////////////////////output error distribution and insert size distribution////////////////////////////

	//ouput error position distribution
	error_log<<"**********Error rate distribution**********"<<endl;
	if(InputParameter.Is_simulate_quality){
		error_log<<"Cycle\tReal_error_rate\tQuality_to_error_rate"<<endl;
  	for(int i=1; i<=Simulate_Cycle_num; i++){
  		error_log<<i<<"\t"<<double(Error_pos_distr[i])/double(Total_read_pair)<<"\t"<<Q_to_Erate_distr[i]/double(Total_read_pair)<<endl;
  		if(i== InputParameter.Read_length){error_log<<endl;}
  	}
	}else{
		error_log<<"Cycle\tReal_error_rate"<<endl;
  	for(int i=1; i<=Simulate_Cycle_num; i++){
  		error_log<<i<<"\t"<<double(Error_pos_distr[i])/double(Total_read_pair)<<endl;
  		if(i== InputParameter.Read_length){error_log<<endl;}
  	}
	}
	delete[] Error_pos_distr;
	delete[] Q_to_Erate_distr;
	
	//output insert size distribution
	insert_log<<"**********Insert size distribution************"<<endl
		<<"insert_size_len"<<"\t"<<"number"<<endl;
	map<int, uint64_t>::const_iterator map_it = InsertSize_distr.begin();
	while (map_it != InsertSize_distr.end())
	{
		insert_log<<map_it->first<<"\t"<<map_it->second<<endl;
		//cout<<map_it->second<<endl;
		map_it++;
	}
	
	if(InputParameter.Is_simulate_GC_bias)
	{
		delete[] GC_bias_abundance;
	}
	
	if(!InputParameter.Is_simulate_quality || !InputParameter.Q_Mode){
    for(int i=0; i<Ref_Base_num; i++)
    {
    	for(int j=0; j<Simulate_Cycle_num; j++)
    	{
    		delete[] Simulation_matrix[i][j];
    	}
    	delete[] Simulation_matrix[i];
    }
    delete[] Simulation_matrix;
	}else{
    for(int i=0; i<Ref_Base_num; i++)
    {
    	for(int j=0; j<Simulate_Cycle_num; j++)
    	{
    		for(int k=0; k<Quality_num; k++)
    		{
    			delete[] Simulation_matrix1[i][j][k];
    		}
    		delete[] Simulation_matrix1[i][j];
    	}
    	delete[] Simulation_matrix1[i];
    }
    delete[] Simulation_matrix1;
    

  	for(int j=0; j<Simulate_Cycle_num; j++)
  	{
  		for(int k=0; k<Quality_num; k++)
  		{
  			delete[] Simulation_matrix2[j][k];
  		}
  		delete[] Simulation_matrix2[j];
  	}
  	delete[] Simulation_matrix2;

	}
	
	time_end = time(NULL);
	cerr<<"All done! Run time: "<<time_end-time_start<<"s."<<endl;
	
	return 0;
}

//get genome sequence and start to simulate read 
void Get_genome(igzstream &inf,igzstream &inf2){
	string line,line2,id,id_line,seq,seq2;
	uint64_t readINgenome=0;

	while (getline(inf,line,'\n'))
	{
		if (line[0]=='>')
		{
			if (seq!="")
			{	
				//another diploid seq
				if(InputParameter.Input_ref2 != ""){
					while(getline(inf2,line2,'\n'))
					{
						if(line2[0] == '>')
						{
							if(seq2!="")
							{
								//cerr <<seq2<<endl;
        				cerr<<"Have finished reading scaffold "<<id<<endl;
        				readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
        				seq="";
        				seq2="";
        				break;
							}
						}else{
							seq2+=line2;
						}
					}
				}else{
					cerr<<"Have finished reading scaffold "<<id<<endl;

					readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
					seq="";
				}
			}
			id_line = line;
			line.erase(0,1);
			int pos=line.find(" ");
			line=line.substr(0,pos);
			id=line;
		}else{
			seq+=line;
		}		
	}
	cerr<<"Have finished reading scaffold "<<id<<endl;
	if(InputParameter.Input_ref2 != ""){
		while(getline(inf2,line2,'\n'))
		{
			if(line2[0] == '>'){continue;}
			seq2+=line2;
		}
		//cerr<<seq2<<endl;
	}
	readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
}

//contral the quantity of simulate reads for each chromosome one by one
uint64_t contral_reads_quantity(string id_line,string id,string &sequence,string &sequence2,uint64_t read_genome)
{
	uint64_t readonchr=0;
	if (sequence.size()<InputParameter.Insertsize_mean)
	{
		return 0;
	}
	//convert lower case to upper case 
	to_upper(sequence);

	uint64_t sequence_length=sequence.size();
	uint64_t reads_pair_num=0;
	
	if (InputParameter.Input_ref2 != "")
	{
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2/2);
	}else{
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2);
	}
	Total_read_pair = Total_read_pair + (uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2);
	
	string id_1 = id+" 1";
	if(InputParameter.Is_simulate_quality){		
		readonchr=simulate_fq_reads(sequence,sequence_length,reads_pair_num,
			id_1,read_genome);
	}else{
		readonchr=simulate_fa_reads(sequence,sequence_length,reads_pair_num,
			id_1,read_genome);
	}
	
	//simulate reads of another diploid genome 
	if (InputParameter.Input_ref2 != "") 
	{
		sequence_length=sequence2.size();
		if (sequence_length<InputParameter.Insertsize_mean)
		{
			return 0;
		}
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2/2);

		uint64_t readonchr2=read_genome+readonchr;
		string id_2 = id+" 2";
		if(InputParameter.Is_simulate_quality){
			readonchr+=simulate_fq_reads(sequence2,sequence_length,reads_pair_num,
				id_2,readonchr2);
		}else{
			readonchr+=simulate_fa_reads(sequence2,sequence_length,reads_pair_num,
				id_2,readonchr2);
		}
	}
	return readonchr;
}


uint64_t simulate_fq_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, uint64_t reads_all)
{
	int whether_check_seq = 0; 
	if(!check_seq(seq)){
		whether_check_seq = 1;
	}
	
	uint64_t reads_count=0;
	cerr<<"Begin to output reads"<<endl;
	for(uint64_t pair_count=0; pair_count < rd_pair; pair_count++)
	{
		//simulate insertsize
		int insertsize = simulate_insertsize(InputParameter.Insertsize_mean,InputParameter.Insertsize_sd);
		if (insertsize<InputParameter.Read_length){pair_count--;continue;}
		if (seqlen<insertsize){return reads_count;}
		uint64_t N = 1000000000000;
		uint64_t pos = (uint64_t)(((uint64_t)((double)rand() / double(RAND_MAX) * N)) % seqlen);
		if (pos+insertsize>seqlen){pair_count--;continue;}
			
		//get insert seq
		string sub_str=seq.substr(pos,insertsize);
	
		//get read1 and read2
		string read1=sub_str.substr(0,InputParameter.Read_length);
		string read2=sub_str.substr(insertsize-InputParameter.Read_length,InputParameter.Read_length);
		
		//check whether contain 'N' or nonbase char
		if(whether_check_seq && (!check_seq(read1) || !check_seq(read2))){
			pair_count--;
			continue;
		}
		
		//simulate GC bias
		if(InputParameter.Is_simulate_GC_bias){
			string check_seq = read1+read2;
			if(simulate_GC_bias(check_seq,GC_bias_abundance)){pair_count--;continue;}
		}
		
		//insertsize statistics
		if(InsertSize_distr[insertsize]>0)
		{
			InsertSize_distr[insertsize]++;
		}else{
			InsertSize_distr[insertsize] = 1;
		}
		
		reads_count++;
		
		if ( InputParameter.Is_cyclization == 1 )
		{
			read1=reversecomplementary(read1);
		}else if (InputParameter.Insertsize_mean>0)
		{
			read2=reversecomplementary(read2);
		}else{
			cout<<"Error:insertsize mean is smaller than 0"<<endl;
			exit(-1);
		}
		
		int selection=int(rand()%2); //0 or 1, for selecting output file randomly
		
		string output_read1, output_read2, output_quality_seq1, output_quality_seq2;
		
		vector<int> error_pos1;
  	vector<char> raw_base1;
  	vector<int> error_pos2;
  	vector<char> raw_base2;
  		
		if(InputParameter.Q_Mode == 0)
		{
  		//simulate read1
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			char ref_base = read1[i];
  			int cycle;
  			if(selection == 0){
  				cycle = i;
  			}else{
  				cycle = i+Simulate_Cycle_num/2;
  			}
  			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num*Quality_num, num);
  			int call_base_num = int(location/Quality_num);
  			char call_base = Bases[call_base_num];
  			if(ref_base != call_base){
  				if(selection == 0){
  					Error_pos_distr[i+1]++;
  				}else{
  					Error_pos_distr[i+1+InputParameter.Read_length]++;
  				}
  				error_pos1.push_back(i);
  				raw_base1.push_back(ref_base);
  			}
  			output_read1.push_back(call_base);
  			int Qscore = location%Quality_num;
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq1.push_back(quality_value);
  			if(selection == 0){
  				Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
  			}else{
  				Q_to_Erate_distr[i+1+InputParameter.Read_length]+= pow(10,double(Qscore)/double(-10));
  			}
  		}
  		
  		//simulate read2
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			char ref_base = read2[i];
  			int cycle;
  			if(selection == 0){
  				cycle = i+Simulate_Cycle_num/2;
  			}else{
  				cycle = i;
  			}
  				
  			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num*Quality_num, num);
  			int call_base_num = int(location/Quality_num);
  			char call_base = Bases[call_base_num];
  			if(ref_base != call_base){
  				if(selection == 0){
  					Error_pos_distr[i+1+InputParameter.Read_length]++;
  				}else{
  					Error_pos_distr[i+1]++;
  				}
  				error_pos2.push_back(i);
  				raw_base2.push_back(ref_base);
  			}
  			output_read2.push_back(call_base);
  			int Qscore = location%Quality_num;
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq2.push_back(quality_value);
  			if(selection == 0){
  				Q_to_Erate_distr[i+1+InputParameter.Read_length]+= pow(10,double(Qscore)/double(-10));
  			}else{
  				Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
  			}
  		}
  		
		}else{
  		//simulate read1
  		
  		int pre_Q = 0;
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			double num2=double(rand())/double(RAND_MAX);
  			char ref_base = read1[i];
  			int cycle;
  			if(selection == 0){
  				cycle = i;
  			}else{
  				cycle = i+Simulate_Cycle_num/2;
  			}
  			
  			char call_base;
  			int Qscore;
  			int location = 0;
  			int location2 = 0;
  			if(cycle == 0 || cycle == Simulate_Cycle_num/2){
  				if(cycle == 0){
  					location = search_location(First_cycle_matrix[alphabet2[ref_base]][0], Seq_Base_num*Quality_num, num);
  				}else{
  					location = search_location(First_cycle_matrix[alphabet2[ref_base]][1], Seq_Base_num*Quality_num, num);
  				}
  				
  //				if(location == 0){cerr<<"num:"<<num<<" cycle:"<<cycle<<" alphabet2[ref_base]:"<<(int)alphabet2[ref_base]<<endl;}
  				
  				if(location == Seq_Base_num*Quality_num){
  					call_base = ref_base;
  					Qscore = Quality_num -1 ;
  //					cerr<<"read1 location == Seq_Base_num*Quality_num"<<endl;
    			} //
    			else{
    				int call_base_num = int(location/Quality_num);
    			  call_base = Bases[call_base_num];
    			  Qscore = location%Quality_num;
    			}
  				
  			}else{
  				int location = search_location(Simulation_matrix2[cycle][pre_Q], Quality_num, num);
  				
  				if(location == Quality_num){
  					Qscore = pre_Q;
    			} //
    			else{
    				Qscore = location;
    			}
  				int location2 = search_location(Simulation_matrix1[alphabet2[ref_base]][cycle][Qscore], Seq_Base_num, num2);
  				if(location2 == Seq_Base_num){
  					call_base = ref_base;
    			} //
    			else{
    				call_base = Bases[location2];
    			}
  			}
  			
  			pre_Q = Qscore;
  			
  			if(ref_base != call_base){
  				if(selection == 0){
  					Error_pos_distr[i+1]++;
  				}else{
  					Error_pos_distr[i+1+InputParameter.Read_length]++;
  				}
  				error_pos1.push_back(i);
  				raw_base1.push_back(ref_base);
  			}
  			output_read1.push_back(call_base);
  			
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq1.push_back(quality_value);
  			if(selection == 0){
  				Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
  			}else{
  				Q_to_Erate_distr[i+1+InputParameter.Read_length]+= pow(10,double(Qscore)/double(-10));
  			}
  		}
  		
  		//simulate read2
  		pre_Q = 0;
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			double num2=double(rand())/double(RAND_MAX);
  			char ref_base = read2[i];
  			int cycle;
  			if(selection == 0){
  				cycle = i+Simulate_Cycle_num/2;
  			}else{
  				cycle = i;
  			}
  			
  			char call_base;
  			int Qscore;
  			int location = 0;
  			int location2 = 0;
  			if(cycle == 0 || cycle == Simulate_Cycle_num/2){
  				if(cycle == 0){
  					location = search_location(First_cycle_matrix[alphabet2[ref_base]][0], Seq_Base_num*Quality_num, num);
  				}else{
  					location = search_location(First_cycle_matrix[alphabet2[ref_base]][1], Seq_Base_num*Quality_num, num);
  				}
  //				if(location == 0){cerr<<"num:"<<num<<" cycle:"<<cycle<<" alphabet2[ref_base]:"<<(int)alphabet2[ref_base]<<endl;}
  				if(location == Seq_Base_num*Quality_num){
  					call_base = ref_base;
  					Qscore = Quality_num-1;
  //					cerr<<"read2 location == Seq_Base_num*Quality_num"<<endl;
    			} //
    			else{
    				int call_base_num = int(location/Quality_num);
    			  call_base = Bases[call_base_num];
    			  Qscore = location%Quality_num;
    			}
  				
  			}else{
  				int location = search_location(Simulation_matrix2[cycle][pre_Q], Quality_num, num);
  				
  				if(location == Quality_num){
  					Qscore = pre_Q;
    			} //
    			else{
    				Qscore = location;
    			}
  				int location2 = search_location(Simulation_matrix1[alphabet2[ref_base]][cycle][Qscore], Seq_Base_num, num2);
  				if(location2 == Seq_Base_num){
  					call_base = ref_base;
    			} //
    			else{
    				call_base = Bases[location2];
    			}
  			}
  			pre_Q = Qscore;
  			if(ref_base != call_base){
  				if(selection == 0){
  					Error_pos_distr[i+1+InputParameter.Read_length]++;
  				}else{
  					Error_pos_distr[i+1]++;
  				}
  				error_pos2.push_back(i);
  				raw_base2.push_back(ref_base);
  			}
  			output_read2.push_back(call_base);
  
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq2.push_back(quality_value);
  			if(selection == 0){
  				Q_to_Erate_distr[i+1+InputParameter.Read_length]+= pow(10,double(Qscore)/double(-10));
  			}else{
  				Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
  			}
  		}
		}
		
		//output simulate reads
		if (reads_count%10000==0)
		{
			cerr<<"Output "<<reads_count<<" pair reads"<<endl;
		}
		
  	//output read file
		if(selection == 0){
			//output read file1
			//text output
			if(!InputParameter.Output_type){
  			Outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				Outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			Outfile1<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file2
  			Outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				Outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			Outfile2<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
  		}else{
  			//*.gz output
  			//output read file1
				Gz_outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				Gz_outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			Gz_outfile1<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file2
				Gz_outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				Gz_outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			Gz_outfile2<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
  		}
		
		}else{
			
			//output read file2
			//text output
			if(!InputParameter.Output_type){
				Outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				Outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			Outfile2<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file1
				Outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				Outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			Outfile1<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
			}else{
				//*.gz output
				//output read file2
				Gz_outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				Gz_outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			Gz_outfile2<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file1
				Gz_outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				Gz_outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			Gz_outfile1<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
			}
		}
	}
	cerr<<"Finish output reads"<<endl;
	return reads_count;
}


uint64_t simulate_fa_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, uint64_t reads_all)
{
	int whether_check_seq = 0; 
	if(!check_seq(seq)){
		whether_check_seq = 1;
	}
	
	uint64_t reads_count=0;
	cerr<<"Begin to output reads"<<endl;
	for(uint64_t pair_count=0; pair_count < rd_pair; pair_count++)
	{
		//simulate insertsize
		int insertsize = simulate_insertsize(InputParameter.Insertsize_mean,InputParameter.Insertsize_sd);
		if (insertsize<InputParameter.Read_length){pair_count--;continue;}
		if (seqlen<insertsize){return reads_count;}
		uint64_t N = 1000000000000;
		uint64_t pos = (uint64_t)(((uint64_t)((double)rand() / double(RAND_MAX) * N)) % seqlen);
		if (pos+insertsize>seqlen){pair_count--;continue;}
			
		//get insert seq
		string sub_str=seq.substr(pos,insertsize);
		
		//get read1 and read2
		string read1=sub_str.substr(0,InputParameter.Read_length);
		string read2=sub_str.substr(insertsize-InputParameter.Read_length,InputParameter.Read_length);

		//check whether contain 'N' or nonbase char
		if(whether_check_seq && (!check_seq(read1) || !check_seq(read2))){
			pair_count--;
			continue;
		}
		
		//simulate GC bias
		if(InputParameter.Is_simulate_GC_bias){
			string check_seq = read1+read2;
			if(simulate_GC_bias(check_seq,GC_bias_abundance)){pair_count--;continue;}
		}
		
		//insertsize statistics
		if(InsertSize_distr[insertsize]>0)
		{
			InsertSize_distr[insertsize]++;
		}else{
			InsertSize_distr[insertsize] = 1;
		}
		
		reads_count++;
		
		if ( InputParameter.Is_cyclization == 1 )
		{
			read1=reversecomplementary(read1);
		}else if (InputParameter.Insertsize_mean>0)
		{
			read2=reversecomplementary(read2);
		}else{
			cout<<"Error:insertsize mean is smaller than 0"<<endl;
			exit(-1);
		}
		
		int selection=int(rand()%2);  //0 or 1, for selecting output file randomly
		
		string output_read1, output_read2;
		
		//simulate read1
		vector<int> error_pos1;
		vector<char> raw_base1;
		for(int i = 0; i < InputParameter.Read_length; i++)
		{
			double num=double(rand())/double(RAND_MAX);
			char ref_base = read1[i];
			int cycle;
			if(selection == 0){
				cycle = i;
			}else{
				cycle = i+Simulate_Cycle_num/2;
			}
			
			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num, num);
			char call_base = Bases[location];
			if(ref_base != call_base){
				if(selection == 0){
					Error_pos_distr[i+1]++;
				}else{
					Error_pos_distr[i+1+InputParameter.Read_length]++;
				}
				error_pos1.push_back(i);
				raw_base1.push_back(ref_base);
			}
			output_read1.push_back(call_base);
		}
		
		//simulate read2
		vector<int> error_pos2;
		vector<char> raw_base2;
		for(int i = 0; i < InputParameter.Read_length; i++)
		{
			double num=double(rand())/double(RAND_MAX);
			char ref_base = read2[i];
			int cycle;
			if(selection == 0){
				cycle = i+Simulate_Cycle_num/2;
			}else{
				cycle = i;
			}
			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num, num);
			char call_base = Bases[location];
			if(ref_base != call_base){
				if(selection == 0){
					Error_pos_distr[i+1+InputParameter.Read_length]++;
				}else{
					Error_pos_distr[i+1]++;
				}
				error_pos2.push_back(i);
				raw_base2.push_back(ref_base);
			}
			output_read2.push_back(call_base);
		}
		
		//output simulate reads
		if (reads_count%10000==0)
		{
			cerr<<"Output "<<reads_count<<" pair reads"<<endl;
		}
		
  	//output read file
		if(selection == 0){
			//output read file1
			//text output
			if(!InputParameter.Output_type){

  			Outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				Outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			Outfile1<<endl<<output_read1<<endl;
    		
    		//output read file2
  			Outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				Outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			Outfile2<<endl<<output_read2<<endl;
  		}else{//*.gz output
				Gz_outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				Gz_outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			Gz_outfile1<<endl<<output_read1<<endl;
    		
    		//output read file2
				Gz_outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				Gz_outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			Gz_outfile2<<endl<<output_read2<<endl;
  		}
		
		}else{
			//output read file2
			//text output
			if(!InputParameter.Output_type){
				Outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				Outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			Outfile2<<endl<<output_read1<<endl;
    		
    		//output read file1
				Outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				Outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			Outfile1<<endl<<output_read2<<endl;
  			
			}else{//*.gz output
				Gz_outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos1.size(); i++)
  			{
  				Gz_outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			}
  			Gz_outfile2<<endl<<output_read1<<endl;
    		
    		//output read file1
				Gz_outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
  			for(int i = 0; i < error_pos2.size(); i++)
  			{
  				Gz_outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			}
  			Gz_outfile1<<endl<<output_read2<<endl;
			}
		}

	}
	cerr<<"Finish output reads"<<endl;
	return reads_count;
}
