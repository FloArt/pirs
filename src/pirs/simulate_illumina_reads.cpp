#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <math.h>
#include <map>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>
#include "gzstream.h"
#include "simulate.h"
#include "load_file.h"
#include "global.h"

using namespace std;

//parameter variable
PARAMETER InputParameter ={100,500,-1,0,0,0,0,0,1,1,1,64,1,5,-1,"","","","","Illumina"};

int Ref_Base_num = 0;  //ATCG: 4
int Statistical_Cycle_num = 0; //the cycle number in Base-calling profile
int Seq_Base_num = 0;  //ATCG: 4
int Quality_num = 0;  //the quality score number in Base-calling profile
int Simulate_Cycle_num = 0; //the cycle number of simulation
double Statistical_average_error_rate = 0; //the average error rate in Base-calling profile

ogzstream Gz_outfile1; 
ogzstream Gz_outfile2;
ofstream Outfile1;
ofstream Outfile2;

ogzstream Infor_outfile;

double*** First_cycle_matrix = NULL;
double*** Simulation_matrix2 = NULL;
double**** Simulation_matrix1 = NULL;  //for call base and quality simulation
double*** Simulation_matrix = NULL; //for simulate fasta
double* GC_bias_abundance = NULL;  //for GC bias simulation 
map<int,uint64_t> InsertSize_distr; //record the insert size distribution 
uint64_t* Error_pos_distr = NULL; //record the error position distribution
double* Q_to_Erate_distr = NULL; //record quality score to error rate distribution
uint64_t Total_read_pair = 0; 

string Indel_rate_str;
vector <double> Vec_ins_rate1;
vector <double> Vec_del_rate1;
vector <double> Vec_ins_rate2;
vector <double> Vec_del_rate2;

//get genome sequence and start to simulate read 
void Get_genome(igzstream &inf,igzstream &inf2);
//contral the quantity of simulate reads for each chromosome one by one
uint64_t contral_reads_quantity(string id_line,string id,string &sequ,string &sequ2,uint64_t read_genome);
//simulate fastq reads
//uint64_t simulate_fq_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, uint64_t reads_all);
uint64_t simulate_fq_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, int i_or_I, uint64_t reads_all);
//simulate fasta reads
uint64_t simulate_fa_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, int i_or_I, uint64_t reads_all);


void SimReads_Usage(){
	cout<<"\nDescription:"<<endl;
	cout<<"   It is a program for simulating Illumina pair-end reads, with a series of characters generate by illumina ";
	cout<<"sequencer, such as insertsize distribution, sequencing error, quality score and GC bias. ";
	cout<<"User should set the mean value and the standard deviation of the normal distribution for simulating insertsize ";
	cout<<"distribution, usually we set the insertsize_sd as 1/20 of the insertsize_mean. The normal distribution ";
	cout<<"function model we used in this program is simulated by Box-muller method. ";
	cout<<"This program simulates Illumina sequencing error, quality score and GC bias according to the empirical distribution profile. ";
	cout<<"User can set the path of profile or using the default file in this program package, which is generated by large real sequencing data. ";
	cout<<"It need two reference genome sequence if you want to simulate reads of diploid(heterozygosis SNP, heterozygosis Indel and structural variation), ";
	cout<<"you can get another diploid genome sequence by the command \"pirs diploid\", but remember that heterozygosis SNP rate and heterozygosis Indel rate only exist in diploid. \n";
	cout<<endl<<"Program: pirs simulate"<<endl;
	cout<<endl<<"Usage:\t./pirs simulate [options]"<<endl;
	cout<<"\t-i  <string>  input_ref1,input reference genome sequence *.fa/*.fa.gz, no default vaule"<<endl;
	cout<<"\t-I  <string>  input_ref2,for diploid genome, input another reference genome sequence which was generated by command \"pirs diploid\""<<endl;
	cout<<"\t-s  <string>  Base-calling profile,input Base-calling profile for simulating sequencing error and quality score,default: (exe_path)"<<BASE_CALLING_PROFILE<<endl;
	cout<<"\t-d  <string>  GC-depth profile,input GC-depth file for simulating GC bias, the default GC bias profiles are determined based on the twice of read length"<<endl;
	cout<<"\t-l  <int>     read_len,set length of read,read1 and read2 have the same length,default:"<<InputParameter.Read_length<<endl;
	cout<<"\t-x  <double>  coverage,set the sequencing coverage(sometimes called depth),default:"<<InputParameter.Coverage<<endl;
	cout<<"\t-m  <int>     insertsize_mean,set the average value of insert size,default:"<<InputParameter.Insertsize_mean<<endl;
	cout<<"\t-v  <int>     insertsize_sd,set the standard deviation of insert sizes, default:insertsize_mean/20"<<endl;
//	cout<<"\t-e  <double>  error_rate,set the average error rate over all cycles,default=average error rate of Base-calling profile"<<endl;
	cout<<"\t-a  <string>  simulate reads indel, set four rate of: read1 insertion, read1 deletion, read2 insertion, read2 deletion,separate the rate with a comma, such as:0.00009,0.00011,0.00015,0.00023,default: 0,0,0,0"<<endl;
	cout<<"\t-g  <int>     simulate GC bias, 0:no, 1:yes, default:"<<InputParameter.Is_simulate_GC_bias<<endl;
	cout<<"\t-q  <int>     simulate quality value, 0:no(fasta), 1:yes(fastq), default:"<<InputParameter.Is_simulate_quality<<endl;
	cout<<"\t-M  <int>     simulate quality value by Quality-transition mode, 0:no, 1:yes, default:"<<InputParameter.Q_Mode<<endl;
	cout<<"\t-Q  <int>     ASCII shift of quality value, generally 64 or 33 for Illumina data, default:"<<InputParameter.Q_shift<<endl;
	cout<<"\t-f  <int>     cyclize insert fragment (influence on PE reads' direction) 0: read1-forward read2-reverse, 1: read1-reverse read2-forward, default:"<<InputParameter.Is_cyclization<<endl;
	cout<<"\t-c  <int>     output file type, 0:text, 1:compressed(*.gz), default:"<<InputParameter.Output_type<<endl;
	cout<<"\t-o  <string>  prefix of output file, default:"<<InputParameter.Output_prefix<<endl;
	cout<<"\t-h            output help infomation."<<endl;
	cout<<endl<<"Example:"<<endl;
	cout<<"\t1. ./pirs simulate -i ref_sequence.fa"<<endl;
	cout<<"\t  Every parameter use the default value."<<endl;
	cout<<"\t2. ./pirs simulate -i ref_sequence.fa -l 100 -x 20 -o human_500_100"<<endl;
	cout<<"\t  Just set read length and coverage you needed."<<endl;
	cout<<"\t3. ./pirs simulate -i ref_sequence.fa -o human -m 600 -v 30"<<endl;
	cout<<"\t  Set insertsize distribution."<<endl;
	cout<<"\t4. ./pirs simulate -i ref_sequence.fa -I ref_seq.snp.indel.invertion.fa.gz -o human "<<endl;
	cout<<"\t  The genome is diploid and you want to produce heterozygosis SNPs  heterozygosis Indels in reads, "<<endl;
	cout<<"\t  the -I input file was generated by command \"pirs diploid\"."<<endl;
	cout<<"\t5. ./pirs simulate -i ref_sequence.fa -g 0 -m 2000 -f 1 -c 0 -o human "<<endl;
	cout<<"\t  simulate no GCbias, cyclize the large insert-size library, output file is text format."<<endl;
	cout<<"\t6. ./pirs simulate -i ref_sequence.fa -q 0 -o human "<<endl;
	cout<<"\t  simulate fasta file, the ouput is in *.fa format."<<endl;
	cout<<"\t7. ./pirs simulate -i ref_sequence.fa -a 0.00009,0.00011,0.00015,0.00023 -l 75 -o human "<<endl;
	cout<<"\t  simulate reads indel error."<<endl;
	exit(-1);
}

void SimReads_Getopt(int argc,char *argv[]){
	int c;
	while ((c=getopt(argc,argv,"i:I:s:d:l:x:m:v:a:f:g:q:M:Q:c:o:h"))!=-1)
	{
		switch(c){
			case 'i': InputParameter.Input_ref1=optarg;break;
			case 'I': InputParameter.Input_ref2=optarg;break;
			case 's': InputParameter.BaseCalling_profile=optarg;break;
			case 'd': InputParameter.GC_depth_profile=optarg;break;
			case 'l': InputParameter.Read_length=atoi(optarg);break;
			case 'x': InputParameter.Coverage=atof(optarg);break;
			case 'm': InputParameter.Insertsize_mean=atoi(optarg);break;
			case 'v': InputParameter.Insertsize_sd=atoi(optarg);break;
			case 'a': Indel_rate_str=optarg;break;
			case 'f': InputParameter.Is_cyclization=atoi(optarg);break;
			case 'g': InputParameter.Is_simulate_GC_bias=atoi(optarg);break;
			case 'q': InputParameter.Is_simulate_quality=atoi(optarg);break;
			case 'M': InputParameter.Q_Mode=atoi(optarg);break;
			case 'Q': InputParameter.Q_shift=atoi(optarg);break;
			case 'c': InputParameter.Output_type=atoi(optarg);break;
			case 'o': InputParameter.Output_prefix=optarg;break;
			case 'h': SimReads_Usage();break;
			default: SimReads_Usage();
		}
	}
}

int simulate_Illumina_reads(int argc, char *argv[])
{
	time_t time_start, time_end;
	time_start = time(NULL);
	srand((unsigned)time(NULL));
	
	if (argc==1)
	{
		SimReads_Usage();
	}
	
	SimReads_Getopt(argc,argv);
	
	argv--;
	
	if(Indel_rate_str.empty())
  {
    InputParameter.Ins_rate1 = 0;
    InputParameter.Del_rate1 = 0;
    InputParameter.Ins_rate2 = 0;
    InputParameter.Del_rate2 = 0;
  }else
  {
  	vector<string> vec_rate;
  	boost::split(vec_rate,Indel_rate_str, boost::is_any_of(" ,\t"), boost::token_compress_on);
  	if(vec_rate.size() != 4)
  	{
  		cerr<<"Error: for option -a, please input four rate separate a comma!"<<endl;exit(-1);
  	}else{
  		InputParameter.Ins_rate1 = atof(vec_rate[0].c_str());
  		InputParameter.Del_rate1 = atof(vec_rate[1].c_str());
  		InputParameter.Ins_rate2 = atof(vec_rate[2].c_str());
  		InputParameter.Del_rate2 = atof(vec_rate[3].c_str());
  		if(InputParameter.Ins_rate1 < 0 || InputParameter.Ins_rate1 > 0.001 || InputParameter.Del_rate1 < 0 || InputParameter.Del_rate1 > 0.001 ||
  			 InputParameter.Ins_rate2 < 0 || InputParameter.Ins_rate2 > 0.001 || InputParameter.Del_rate2 < 0 || InputParameter.Del_rate2 > 0.001)
  		{
  			cerr<<"Error: reads indel rate should be set between 0 and 0.001, please check option -a !"<<endl;
  			exit(-1);
  		}
  	}
  }
	
	//set insertsize sd default value
	if(InputParameter.Insertsize_sd == -1){InputParameter.Insertsize_sd = int(InputParameter.Insertsize_mean/20);}
	//check parameter
	if(InputParameter.Input_ref1 == ""){cerr<<"Error: there is not default value with option -i, please input reference sequence!"<<endl;exit(-1);}
	if(InputParameter.Read_length <= 0){cerr<<"Error: read length should be set bigger than 0, please check option -l !"<<endl;exit(-1);}
	if(InputParameter.Coverage <= 0){cerr<<"Error: coverage should be set bigger than 0, please check option -x !"<<endl;exit(-1);}
	if(InputParameter.Insertsize_mean < InputParameter.Read_length){cerr<<"Error: insertize mean should be set bigger than read_length, please check option -m !"<<endl;exit(-1);}
	if(InputParameter.Insertsize_sd < 0){cerr<<"Error: insertsize_sd should be set bigger than 0, please check option -v !"<<endl;exit(-1);}
	if(InputParameter.Error_rate != -1 && InputParameter.Error_rate < 0 || InputParameter.Error_rate >= 1){cerr<<"Error: error_rate should be set between 0 and 1, or set -1 to simulate default error rate according with error profile, please check option -e !"<<endl;exit(-1);}
	if(InputParameter.Is_cyclization != 0 && InputParameter.Is_cyclization != 1){cerr<<"Error: Is_cyclization should be set 0 or 1, please check option -f !"<<endl;exit(-1);}
	if(InputParameter.Is_simulate_GC_bias != 0 && InputParameter.Is_simulate_GC_bias != 1){cerr<<"Error: Is_simulate_GC_bias should be set 0 or 1, please check option -g !"<<endl;exit(-1);}
	if(InputParameter.Is_simulate_quality != 0 && InputParameter.Is_simulate_quality != 1){cerr<<"Error: Is_simulate_quality should be set 0 or 1, please check option -q !"<<endl;exit(-1);}
	if(InputParameter.Q_Mode != 0 && InputParameter.Q_Mode != 1){cerr<<"Error: Q_Mode should be set 0 or 1, please check option -M !"<<endl;exit(-1);}
	if(InputParameter.Output_type != 0 && InputParameter.Output_type != 1){cerr<<"Error: output_type should be set 0 or 1, please check option -c !"<<endl;exit(-1);}
	
	set_rate(InputParameter.Read_length, InputParameter.Ins_rate1, 2, Vec_ins_rate1);
	set_rate(InputParameter.Read_length, InputParameter.Del_rate1, 2, Vec_del_rate1);
	set_rate(InputParameter.Read_length, InputParameter.Ins_rate2, 2, Vec_ins_rate2);
	set_rate(InputParameter.Read_length, InputParameter.Del_rate2, 2, Vec_del_rate2);
	
	//set the simulate cycle number
	Simulate_Cycle_num = InputParameter.Read_length*2;
	//initialize error position distribution table
	Error_pos_distr = new uint64_t[Simulate_Cycle_num+1];
	Q_to_Erate_distr = new double[Simulate_Cycle_num+1];
	for(int i=0; i<=Simulate_Cycle_num; i++)
	{
		Error_pos_distr[i] = 0;
		Q_to_Erate_distr[i] = 0.0;
	}
	
	//input file
	igzstream infile; 
	igzstream infile2;
	//output file
	ofstream insert_log;
	ofstream error_log;
	//check and open file
	set_and_check_file( InputParameter, infile, infile2, Outfile1,	Outfile2, Gz_outfile1, Gz_outfile2, insert_log, error_log, Infor_outfile);
	
	
	////////////////////Load error profile///////////////////////
	
	string exe_path = argv[0]; //program package path
	
	cerr<<"Start to preview error profile..."<<endl;
	//get dimensions of error profile  
	preview_BaseCalling_profile (InputParameter, exe_path, Ref_Base_num, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate);
  cerr << "Dimensions of error profile:\n";
  cerr << "       Ref_Base_num: " << Ref_Base_num << endl;
  cerr << "       Statistical_Cycle_num: " << Statistical_Cycle_num << endl;
  cerr << "       Seq_Base_num: " << Seq_Base_num << endl;
  cerr << "       Quality_num: " << Quality_num << endl;
  cerr <<	"       "<<InputParameter.Read_length<<"bp reads total average error rate: "<< Statistical_average_error_rate <<endl;
	
	//initialize simulation matrix
	if(InputParameter.Is_simulate_quality && InputParameter.Q_Mode == 1){ 
  	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num*Quality_num
  	First_cycle_matrix = new double**[Ref_Base_num];
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		First_cycle_matrix[i] = new double*[2];
  		for(int j=0; j<2; j++)
  		{
  			First_cycle_matrix[i][j] = new double[Seq_Base_num*Quality_num];
  			for(int k=0; k<Seq_Base_num*Quality_num; k++)
  			{
  				First_cycle_matrix[i][j][k] = 0;
  			}
  		}
  	}

  	Simulation_matrix1 = new double***[Ref_Base_num];
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		Simulation_matrix1[i] = new double**[Simulate_Cycle_num];
  		for(int j=0; j<Simulate_Cycle_num; j++)
  		{
  			Simulation_matrix1[i][j] = new double*[Quality_num];
  			for(int k=0; k<Quality_num; k++)
  			{
  				Simulation_matrix1[i][j][k] = new double[Seq_Base_num];
  				for(int l=0; l<Seq_Base_num; l++)
  				{
  					Simulation_matrix1[i][j][k][l] = 0;
  				}
  			}
  		}
  	}
  	
		Simulation_matrix2 = new double**[Simulate_Cycle_num];
		for(int i=0; i<Simulate_Cycle_num; i++)
		{
			Simulation_matrix2[i] = new double*[Quality_num];
			for(int j=0; j<Quality_num; j++)
			{
  			Simulation_matrix2[i][j] = new double[Quality_num];
  			for(int k=0; k<Quality_num; k++)
  			{
  				Simulation_matrix2[i][j][k] = 0;
  			}
			}
		}
  }else{ 
  	if(InputParameter.Is_simulate_quality){
    	//simulate fq read matrix
    	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num*Quality_num
    	Simulation_matrix = new double**[Ref_Base_num];
    	for(int i=0; i<Ref_Base_num; i++)
    	{
    		Simulation_matrix[i] = new double*[Simulate_Cycle_num];
    		for(int j=0; j<Simulate_Cycle_num; j++)
    		{
    			Simulation_matrix[i][j] = new double[Seq_Base_num*Quality_num];
    			for(int k=0; k<Seq_Base_num*Quality_num; k++)
    			{
    				Simulation_matrix[i][j][k] = 0;
    			}
    		}
    	}
  	}else{
    	//simulate fa read matrix
    	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num
    	Simulation_matrix = new double**[Ref_Base_num];
    	for(int i=0; i<Ref_Base_num; i++)
    	{
    		Simulation_matrix[i] = new double*[Simulate_Cycle_num];
    		for(int j=0; j<Simulate_Cycle_num; j++)
    		{
    			Simulation_matrix[i][j] = new double[Seq_Base_num];
    			for(int k=0; k<Seq_Base_num; k++)
    			{
    				Simulation_matrix[i][j][k] = 0;
    			}
    		}
    	}
  	}
  }
	
	string base_calling_profile;
	//get the simulation matrix
	if(InputParameter.Is_simulate_quality && InputParameter.Q_Mode == 1){
		base_calling_profile = load_BaseCalling_profile(InputParameter, exe_path, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix1, First_cycle_matrix);
		base_calling_profile = load_BaseCalling_profile(InputParameter, exe_path, Statistical_Cycle_num, Ref_Base_num, Simulate_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix2);
	}else{
		base_calling_profile = load_BaseCalling_profile(InputParameter, exe_path, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix);
	}
	///////////////////////////load GC bias profile///////////////////////////////
	
	//get GC abundance for simulate GC bias
	string gc_bias_profile;
	if(InputParameter.Is_simulate_GC_bias){
		GC_bias_abundance = new double[101];
		for(int i = 0; i <= 100; i++)
		{
			GC_bias_abundance[i] = 0.0;
		}
		gc_bias_profile = load_GC_depth_profile (InputParameter, exe_path, GC_bias_abundance);
	}

	string ref2_info = InputParameter.Input_ref2;
	if(InputParameter.Input_ref2.empty())
	{
		ref2_info = "none, just simulate reads from haploid." ;
	}
	string Is_cyc = "yes";
	if(InputParameter.Is_cyclization == 0)
	{
		Is_cyc = "no";
	}
	string Is_simGC = "yes";
	if(InputParameter.Is_simulate_GC_bias == 0)
	{
		Is_simGC = "no";
	}
	string Is_simQual = "yes";
	if(InputParameter.Is_simulate_quality)
	{
		Is_simQual = "no";
	}
	string Is_qt = "yes";
	if(InputParameter.Q_Mode == 0)
	{
		Is_qt = "no";
	}
	string outtype = "compressed(*.gz)";
	if(InputParameter.Output_type == 0)
	{
		outtype = "text";
	}
	
	Infor_outfile<<"#input reference1: "<<InputParameter.Input_ref1<<endl
		<<"#input reference2: "<<ref2_info<<endl
		<<"#base-Calling profile: "<<base_calling_profile<<endl
		<<"#GC content-coverage profile: "<<gc_bias_profile<<endl
		<<"#read length: "<<InputParameter.Read_length<<endl
		<<"#data coverage: "<<InputParameter.Coverage<<endl
		<<"#mean of insertsize: "<<InputParameter.Insertsize_mean<<endl
		<<"#standard deviation of insert sizes: "<<InputParameter.Insertsize_sd<<endl
		<<"#insertion rate of read1: "<<InputParameter.Ins_rate1<<endl
		<<"#deletion rate of read1: "<<InputParameter.Del_rate1<<endl
		<<"#insertion rate of read2: "<<InputParameter.Ins_rate2<<endl
		<<"#deletion rate of read2: "<<InputParameter.Del_rate2<<endl
		<<"#cyclization: "<<Is_cyc<<endl
		<<"#simulate GC content-coverage bias: "<<Is_simGC<<endl
		<<"#reads file output type: "<<outtype<<endl
		<<"#output prefix: "<<InputParameter.Output_prefix<<endl
		<<"#simulate quality value: "<<Is_simQual<<endl;
		
	if(InputParameter.Is_simulate_quality == 1)
	{
		Infor_outfile<<"#simulate quality value by Quality-transition mode: "<< Is_qt<<endl
			<<"#ASCII shift of quality value: "<<InputParameter.Q_shift<<endl;
	}
	Infor_outfile<<endl<<"#read_id\tinsert_size\t-i/-I\tchr\t+/-\tposition\t substitution\tinsertion\tdeletion"<<endl;
	
	
	///////////////////////////get genome seq and start to simulate reads/////////////////////////////
	
	//start simulation
	Get_genome(infile,infile2);
	
	
	/////////////////////////output error distribution and insert size distribution////////////////////////////

	//ouput error position distribution
	error_log<<"**********Error rate distribution**********"<<endl;
	if(InputParameter.Is_simulate_quality){
		error_log<<"Cycle\tReal_error_rate\tQuality_to_error_rate"<<endl;
  	for(int i=1; i<=Simulate_Cycle_num; i++){
  		error_log<<i<<"\t"<<double(Error_pos_distr[i])/double(Total_read_pair)<<"\t"<<Q_to_Erate_distr[i]/double(Total_read_pair)<<endl;
  		if(i== InputParameter.Read_length){error_log<<endl;}
  	}
	}else{
		error_log<<"Cycle\tReal_error_rate"<<endl;
  	for(int i=1; i<=Simulate_Cycle_num; i++){
  		error_log<<i<<"\t"<<double(Error_pos_distr[i])/double(Total_read_pair)<<endl;
  		if(i== InputParameter.Read_length){error_log<<endl;}
  	}
	}
	delete[] Error_pos_distr;
	delete[] Q_to_Erate_distr;
	
	//output insert size distribution
	insert_log<<"**********Insert size distribution************"<<endl
		<<"insert_size_len"<<"\t"<<"number"<<endl;
	map<int, uint64_t>::const_iterator map_it = InsertSize_distr.begin();
	while (map_it != InsertSize_distr.end())
	{
		insert_log<<map_it->first<<"\t"<<map_it->second<<endl;
		//cout<<map_it->second<<endl;
		map_it++;
	}
	
	if(InputParameter.Is_simulate_GC_bias)
	{
		delete[] GC_bias_abundance;
	}
	
	if(!InputParameter.Is_simulate_quality || !InputParameter.Q_Mode){
    for(int i=0; i<Ref_Base_num; i++)
    {
    	for(int j=0; j<Simulate_Cycle_num; j++)
    	{
    		delete[] Simulation_matrix[i][j];
    	}
    	delete[] Simulation_matrix[i];
    }
    delete[] Simulation_matrix;
	}else{
    for(int i=0; i<Ref_Base_num; i++)
    {
    	for(int j=0; j<Simulate_Cycle_num; j++)
    	{
    		for(int k=0; k<Quality_num; k++)
    		{
    			delete[] Simulation_matrix1[i][j][k];
    		}
    		delete[] Simulation_matrix1[i][j];
    	}
    	delete[] Simulation_matrix1[i];
    }
    delete[] Simulation_matrix1;
    

  	for(int j=0; j<Simulate_Cycle_num; j++)
  	{
  		for(int k=0; k<Quality_num; k++)
  		{
  			delete[] Simulation_matrix2[j][k];
  		}
  		delete[] Simulation_matrix2[j];
  	}
  	delete[] Simulation_matrix2;

	}
	
	time_end = time(NULL);
	cerr<<"All done! Run time: "<<time_end-time_start<<"s."<<endl;
	
	return 0;
}

//get genome sequence and start to simulate read 
void Get_genome(igzstream &inf,igzstream &inf2){
	string line,line2,id,id_line,seq,seq2;
	uint64_t readINgenome=0;

	while (getline(inf,line,'\n'))
	{
		if (line[0]=='>')
		{
			if (seq!="")
			{	
				//another diploid seq
				if(InputParameter.Input_ref2 != ""){
					while(getline(inf2,line2,'\n'))
					{
						if(line2[0] == '>')
						{
							if(seq2!="")
							{
								//cerr <<seq2<<endl;
        				cerr<<"Have finished reading scaffold "<<id<<endl;
        				readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
        				seq="";
        				seq2="";
        				break;
							}
						}else{
							seq2+=line2;
						}
					}
				}else{
					cerr<<"Have finished reading scaffold "<<id<<endl;

					readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
					seq="";
				}
			}
			id_line = line;
			line.erase(0,1);
			int pos=line.find(" ");
			line=line.substr(0,pos);
			id=line;
		}else{
			seq+=line;
		}		
	}
	cerr<<"Have finished reading scaffold "<<id<<endl;
	if(InputParameter.Input_ref2 != ""){
		while(getline(inf2,line2,'\n'))
		{
			if(line2[0] == '>'){continue;}
			seq2+=line2;
		}
		//cerr<<seq2<<endl;
	}
	readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
}

//contral the quantity of simulate reads for each chromosome one by one
uint64_t contral_reads_quantity(string id_line,string id,string &sequence,string &sequence2,uint64_t read_genome)
{
	uint64_t readonchr=0;
	if (sequence.size()<InputParameter.Insertsize_mean)
	{
		return 0;
	}
	//convert lower case to upper case 
	to_upper(sequence);

	uint64_t sequence_length=sequence.size();
	uint64_t reads_pair_num=0;
	
	if (InputParameter.Input_ref2 != "")
	{
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2/2);
	}else{
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2);
	}
	Total_read_pair = Total_read_pair + (uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2);
	
//	string id_1 = id+" 1";
	if(InputParameter.Is_simulate_quality){		
		readonchr=simulate_fq_reads(sequence,sequence_length,reads_pair_num,
			id, 1,read_genome);
	}else{
		readonchr=simulate_fa_reads(sequence,sequence_length,reads_pair_num,
			id, 1, read_genome);
	}
	
	//simulate reads of another diploid genome 
	if (InputParameter.Input_ref2 != "") 
	{
		sequence_length=sequence2.size();
		if (sequence_length<InputParameter.Insertsize_mean)
		{
			return 0;
		}
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2/2);

		uint64_t readonchr2=read_genome+readonchr;
//		string id_2 = id+" 2";
		if(InputParameter.Is_simulate_quality){
			readonchr+=simulate_fq_reads(sequence2,sequence_length,reads_pair_num,
				id, 2, readonchr2);
		}else{
			readonchr+=simulate_fa_reads(sequence2,sequence_length,reads_pair_num,
				id, 2, readonchr2);
		}
	}
	return readonchr;
}


uint64_t simulate_fq_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, int i_or_I, uint64_t reads_all)
{
	int whether_check_seq = 0; 
	if(!check_seq(seq)){
		whether_check_seq = 1;
	}
	
	uint64_t reads_count=0;
	cerr<<"Begin to output reads"<<endl;
	for(uint64_t pair_count=0; pair_count < rd_pair; pair_count++)
	{
		//simulate insertsize
		int insertsize = simulate_insertsize(InputParameter.Insertsize_mean,InputParameter.Insertsize_sd);
		if (insertsize<InputParameter.Read_length){pair_count--;continue;}
		if (seqlen<insertsize){return reads_count;}
		uint64_t N = 1000000000000;
		uint64_t pos = (uint64_t)(((uint64_t)((double)rand() / double(RAND_MAX) * N)) % seqlen);
		if (pos+insertsize>seqlen){pair_count--;continue;}
			
		//get insert seq
		string sub_str=seq.substr(pos,insertsize);
		
		int selection=int(rand()%2); //0 or 1, for selecting output file randomly
		
		string ref_read1, ref_read2;
		int r1_slen, r2_slen;
		map<int,char,less<int> > indel1;
		map<int,char,less<int> > indel2;
		if(selection == 0){
  		r1_slen = simulate_reads_indel(Vec_del_rate1, Vec_ins_rate1, indel1, InputParameter.Read_length);
  		ref_read1=sub_str.substr(0, InputParameter.Read_length-r1_slen);
  		
  		r2_slen = simulate_reads_indel(Vec_del_rate2, Vec_ins_rate2, indel2, InputParameter.Read_length);
  		ref_read2=sub_str.substr(insertsize-InputParameter.Read_length+r2_slen, InputParameter.Read_length-r2_slen);
		}else{
  		r1_slen = simulate_reads_indel(Vec_del_rate2, Vec_ins_rate2, indel1, InputParameter.Read_length);
  		ref_read1=sub_str.substr(0, InputParameter.Read_length-r1_slen);
  		
  		r2_slen = simulate_reads_indel(Vec_del_rate1, Vec_ins_rate1, indel2, InputParameter.Read_length);
  		ref_read2=sub_str.substr(insertsize-InputParameter.Read_length+r2_slen, InputParameter.Read_length-r2_slen);
		}
		
		//check whether contain 'N' or nonbase char
		if(whether_check_seq && (!check_seq(ref_read1) || !check_seq(ref_read2))){
			pair_count--;
			continue;
		}
		
		//simulate GC bias
		if(InputParameter.Is_simulate_GC_bias){
			string check_seq = ref_read1+ref_read2;
			if(simulate_GC_bias(check_seq,GC_bias_abundance)){pair_count--;continue;}
		}
		
	  string read1;
		string read2;
		
		//insertsize statistics
		if(InsertSize_distr[insertsize]>0)
		{
			InsertSize_distr[insertsize]++;
		}else{
			InsertSize_distr[insertsize] = 1;
		}
		
		reads_count++;
		
		if ( InputParameter.Is_cyclization == 1 )
		{
			ref_read1=reversecomplementary(ref_read1);
			read1=ref2read(ref_read1, indel1);
			read2=ref2read(ref_read2, indel2);
		}else if (InputParameter.Insertsize_mean>0)
		{
			read1=ref2read(ref_read1, indel1);
			ref_read2=reversecomplementary(ref_read2);
			read2=ref2read(ref_read2, indel2);
		}else{
			cout<<"Error:insertsize mean is smaller than 0"<<endl;
			exit(-1);
		}
		
//		int selection=int(rand()%2); //0 or 1, for selecting output file randomly
		
		string output_read1, output_read2, output_quality_seq1, output_quality_seq2;
		
		vector<int> error_pos1;
  	vector<char> raw_base1;
  	vector<int> error_pos2;
  	vector<char> raw_base2;
  		
		if(InputParameter.Q_Mode == 0)
		{
  		//simulate read1
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			char ref_base = read1[i];
  			int cycle;
  			if(selection == 0){
  				cycle = i;
  			}else{
  				cycle = i+Simulate_Cycle_num/2;
  			}
  			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num*Quality_num, num);
  			int call_base_num = int(location/Quality_num);
  			char call_base = Bases[call_base_num];
  			if(ref_base != call_base){
  				if(selection == 0){
  					Error_pos_distr[i+1]++;
  				}else{
  					Error_pos_distr[i+1+InputParameter.Read_length]++;
  				}
  				error_pos1.push_back(i);
  				raw_base1.push_back(ref_base);
  			}
  			output_read1.push_back(call_base);
  			int Qscore = location%Quality_num;
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq1.push_back(quality_value);
  			if(selection == 0){
  				Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
  			}else{
  				Q_to_Erate_distr[i+1+InputParameter.Read_length]+= pow(10,double(Qscore)/double(-10));
  			}
  		}
  		
  		//simulate read2
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			char ref_base = read2[i];
  			int cycle;
  			if(selection == 0){
  				cycle = i+Simulate_Cycle_num/2;
  			}else{
  				cycle = i;
  			}
  				
  			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num*Quality_num, num);
  			int call_base_num = int(location/Quality_num);
  			char call_base = Bases[call_base_num];
  			if(ref_base != call_base){
  				if(selection == 0){
  					Error_pos_distr[i+1+InputParameter.Read_length]++;
  				}else{
  					Error_pos_distr[i+1]++;
  				}
  				error_pos2.push_back(i);
  				raw_base2.push_back(ref_base);
  			}
  			output_read2.push_back(call_base);
  			int Qscore = location%Quality_num;
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq2.push_back(quality_value);
  			if(selection == 0){
  				Q_to_Erate_distr[i+1+InputParameter.Read_length]+= pow(10,double(Qscore)/double(-10));
  			}else{
  				Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
  			}
  		}
  		
		}else{
  		//simulate read1
  		
  		int pre_Q = 0;
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			double num2=double(rand())/double(RAND_MAX);
  			char ref_base = read1[i];
  			int cycle;
  			if(selection == 0){
  				cycle = i;
  			}else{
  				cycle = i+Simulate_Cycle_num/2;
  			}
  			
  			char call_base;
  			int Qscore;
  			int location = 0;
  			int location2 = 0;
  			if(cycle == 0 || cycle == Simulate_Cycle_num/2){
  				if(cycle == 0){
  					location = search_location(First_cycle_matrix[alphabet2[ref_base]][0], Seq_Base_num*Quality_num, num);
  				}else{
  					location = search_location(First_cycle_matrix[alphabet2[ref_base]][1], Seq_Base_num*Quality_num, num);
  				}
  				
  //				if(location == 0){cerr<<"num:"<<num<<" cycle:"<<cycle<<" alphabet2[ref_base]:"<<(int)alphabet2[ref_base]<<endl;}
  				
  				if(location == Seq_Base_num*Quality_num){
  					call_base = ref_base;
  					Qscore = Quality_num -1 ;
  //					cerr<<"read1 location == Seq_Base_num*Quality_num"<<endl;
    			} //
    			else{
    				int call_base_num = int(location/Quality_num);
    			  call_base = Bases[call_base_num];
    			  Qscore = location%Quality_num;
    			}
  				
  			}else{
  				int location = search_location(Simulation_matrix2[cycle][pre_Q], Quality_num, num);
  				
  				if(location == Quality_num){
  					Qscore = pre_Q;
    			} //
    			else{
    				Qscore = location;
    			}
  				int location2 = search_location(Simulation_matrix1[alphabet2[ref_base]][cycle][Qscore], Seq_Base_num, num2);
  				if(location2 == Seq_Base_num){
  					call_base = ref_base;
    			} //
    			else{
    				call_base = Bases[location2];
    			}
  			}
  			
  			pre_Q = Qscore;
  			
  			if(ref_base != call_base){
  				if(selection == 0){
  					Error_pos_distr[i+1]++;
  				}else{
  					Error_pos_distr[i+1+InputParameter.Read_length]++;
  				}
  				error_pos1.push_back(i);
  				raw_base1.push_back(ref_base);
  			}
  			output_read1.push_back(call_base);
  			
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq1.push_back(quality_value);
  			if(selection == 0){
  				Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
  			}else{
  				Q_to_Erate_distr[i+1+InputParameter.Read_length]+= pow(10,double(Qscore)/double(-10));
  			}
  		}
  		
  		//simulate read2
  		pre_Q = 0;
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			double num2=double(rand())/double(RAND_MAX);
  			char ref_base = read2[i];
  			int cycle;
  			if(selection == 0){
  				cycle = i+Simulate_Cycle_num/2;
  			}else{
  				cycle = i;
  			}
  			
  			char call_base;
  			int Qscore;
  			int location = 0;
  			int location2 = 0;
  			if(cycle == 0 || cycle == Simulate_Cycle_num/2){
  				if(cycle == 0){
  					location = search_location(First_cycle_matrix[alphabet2[ref_base]][0], Seq_Base_num*Quality_num, num);
  				}else{
  					location = search_location(First_cycle_matrix[alphabet2[ref_base]][1], Seq_Base_num*Quality_num, num);
  				}
  //				if(location == 0){cerr<<"num:"<<num<<" cycle:"<<cycle<<" alphabet2[ref_base]:"<<(int)alphabet2[ref_base]<<endl;}
  				if(location == Seq_Base_num*Quality_num){
  					call_base = ref_base;
  					Qscore = Quality_num-1;
  //					cerr<<"read2 location == Seq_Base_num*Quality_num"<<endl;
    			} //
    			else{
    				int call_base_num = int(location/Quality_num);
    			  call_base = Bases[call_base_num];
    			  Qscore = location%Quality_num;
    			}
  				
  			}else{
  				int location = search_location(Simulation_matrix2[cycle][pre_Q], Quality_num, num);
  				
  				if(location == Quality_num){
  					Qscore = pre_Q;
    			} //
    			else{
    				Qscore = location;
    			}
    			//cerr<<"ref_base:"<<ref_base<<" cycle:"<<cycle<<" Qscore:"<<Qscore<<" Seq_Base_num:"<<Seq_Base_num<<" num2:"<<Seq_Base_num<<endl;
  				int location2 = search_location(Simulation_matrix1[alphabet2[ref_base]][cycle][Qscore], Seq_Base_num, num2);
  				if(location2 == Seq_Base_num){
  					call_base = ref_base;
    			} //
    			else{
    				call_base = Bases[location2];
    			}
  			}
  			pre_Q = Qscore;
  			if(ref_base != call_base){
  				if(selection == 0){
  					Error_pos_distr[i+1+InputParameter.Read_length]++;
  				}else{
  					Error_pos_distr[i+1]++;
  				}
  				error_pos2.push_back(i);
  				raw_base2.push_back(ref_base);
  			}
  			output_read2.push_back(call_base);
  
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq2.push_back(quality_value);
  			if(selection == 0){
  				Q_to_Erate_distr[i+1+InputParameter.Read_length]+= pow(10,double(Qscore)/double(-10));
  			}else{
  				Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
  			}
  		}
		}
		
		//output simulate reads
		if (reads_count%10000==0)
		{
			cerr<<"Output "<<reads_count<<" pair reads"<<endl;
		}
		
  	//output read file
		if(selection == 0){
			//output read file1
			//text output
			
			//read1 information
			Infor_outfile<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<"+"<<"\t"<<pos+1<<"\t";
  		for(int i = 0; i < error_pos1.size(); i++)
  		{
  			Infor_outfile<<error_pos1[i]+1<<","<<raw_base1[i]<<"->"<< output_read1[error_pos1[i]] <<";";
  		}
  		if(error_pos1.size() == 0){
  			Infor_outfile<<"-";
  		}
  		Infor_outfile<<"\t";
  		
  		if(indel1.size() == 0){
  			Infor_outfile<<"-"<<"\t"<<"-";
  		}else{
  			string inser_inf;
  			string delet_inf;
    		int k=0;
    		int j=0;
      	for(size_t i=0; i<ref_read1.size();){
          //cout<<i<<"\t"<<k<<endl;
          if(indel1.count(k)==0){
             i++; k++; 
          }
          else if(indel1[k]=='-'){
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          	delet_inf += tem + "," + ref_read1[i] + ";";
            i++;k++;j--;
          }
          else{
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          		inser_inf += tem + "," + indel1[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
              k++;
              j++;
          }
      	}
      	while(indel1.count(k)>0){
          int num = k+j;
          string tem = boost::lexical_cast<string>(num);
          inser_inf += tem + "," + indel1[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
          k++;
          j++;
      	}
      	if(inser_inf.empty()){
      		Infor_outfile<<"-"<<"\t";
      	}else{
      		Infor_outfile<<inser_inf<<"\t";
      	}
      	if(delet_inf.empty()){
      		Infor_outfile<<"-";
      	}else{
      		Infor_outfile<<delet_inf;
      	}
    	}
    	Infor_outfile<<endl;
    	
    	//read2 information
			Infor_outfile<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<"-"<<"\t"<<pos+insertsize-InputParameter.Read_length-r2_slen+1<<"\t";
  		for(int i = 0; i < error_pos2.size(); i++)
  		{
  			Infor_outfile<<error_pos2[i]+1<<","<<raw_base2[i]<<"->"<< output_read2[error_pos2[i]] <<";";
  		}
  		if(error_pos2.size() == 0){
  			Infor_outfile<<"-";
  		}
  		Infor_outfile<<"\t";
  		
  		if(indel2.size() == 0){
  			Infor_outfile<<"-"<<"\t"<<"-"<<endl;
  		}else{
  			string inser_inf;
  			string delet_inf;
    		int k=0;
    		int j=0;
      	for(size_t i=0; i<ref_read2.size();){
          //cout<<i<<"\t"<<k<<endl;
          if(indel2.count(k)==0){
             i++; k++; 
          }
          else if(indel2[k]=='-'){
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          	delet_inf += tem + "," + ref_read2[i] + ";";
            i++;k++;j--;
          }
          else{
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          		inser_inf += tem + "," + indel2[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
              k++;
              j++;
          }
      	}
      	while(indel2.count(k)>0){
          int num = k+j;
          string tem = boost::lexical_cast<string>(num);
          inser_inf += tem + "," + indel2[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
          k++;
          j++;
      	}
      	if(inser_inf.empty()){
      		Infor_outfile<<"-"<<"\t";
      	}else{
      		Infor_outfile<<inser_inf<<"\t";
      	}
      	if(delet_inf.empty()){
      		Infor_outfile<<"-"<<endl;
      	}else{
      		Infor_outfile<<delet_inf<<endl;
      	}
    	}
  		
			if(!InputParameter.Output_type){
//  			Outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos1.size(); i++)
//  			{
//  				Outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
//  			}
				Outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
  			Outfile1<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file2
//  			Outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length-r2_slen+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos2.size(); i++)
//  			{
//  				Outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
//  			}
				Outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
  			Outfile2<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
  		}else{
  			//*.gz output
  			//output read file1
//				Gz_outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos1.size(); i++)
//  			{
//  				Gz_outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
//  			}
				Gz_outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
  			Gz_outfile1<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file2
//				Gz_outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length-r2_slen+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos2.size(); i++)
//  			{
//  				Gz_outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
//  			}
				Gz_outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
  			Gz_outfile2<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
  		}
  	
		
		}else{

			//read1 information
			Infor_outfile<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<"-"<<"\t"<<pos+insertsize-InputParameter.Read_length-r1_slen+1<<"\t";
  		for(int i = 0; i < error_pos2.size(); i++)
  		{
//  			Infor_outfile<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
  			Infor_outfile<<error_pos2[i]+1<<","<<raw_base2[i]<<"->"<< output_read2[error_pos2[i]] <<";";
  		}
  		if(error_pos2.size() == 0){
  			Infor_outfile<<"-";
  		}
  		Infor_outfile<<"\t";
  		
  		if(indel2.size() == 0){
  			Infor_outfile<<"-"<<"\t"<<"-";
  		}else{
  			string inser_inf;
  			string delet_inf;
    		int k=0;
    		int j=0;
      	for(size_t i=0; i<ref_read2.size();){
          //cout<<i<<"\t"<<k<<endl;
          if(indel2.count(k)==0){
             i++; k++; 
          }
          else if(indel2[k]=='-'){
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          	delet_inf += tem + "," + ref_read2[i] + ";";
            i++;k++;j--;
          }
          else{
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          		inser_inf += tem + "," + indel2[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
              k++;
              j++;
          }
      	}
      	while(indel2.count(k)>0){
          int num = k+j;
          string tem = boost::lexical_cast<string>(num);
          inser_inf += tem + "," + indel2[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
          k++;
          j++;
      	}
      	if(inser_inf.empty()){
      		Infor_outfile<<"-"<<"\t";
      	}else{
      		Infor_outfile<<inser_inf<<"\t";
      	}
      	if(delet_inf.empty()){
      		Infor_outfile<<"-";
      	}else{
      		Infor_outfile<<delet_inf;
      	}
    	}
    	Infor_outfile<<endl;
    	
    	//read2 information
			Infor_outfile<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<"+"<<"\t"<<pos+1<<"\t";
  		for(int i = 0; i < error_pos1.size(); i++)
  		{
//  			Infor_outfile<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			Infor_outfile<<error_pos1[i]+1<<","<<raw_base1[i]<<"->"<< output_read1[error_pos1[i]] <<";";
  		}
  		if(error_pos1.size() == 0){
  			Infor_outfile<<"-";
  		}
  		Infor_outfile<<"\t";
  		
  		if(indel1.size() == 0){
  			Infor_outfile<<"-"<<"\t"<<"-"<<endl;
  		}else{
  			string inser_inf;
  			string delet_inf;
    		int k=0;
    		int j=0;
      	for(size_t i=0; i<ref_read1.size();){
          //cout<<i<<"\t"<<k<<endl;
          if(indel1.count(k)==0){
             i++; k++; 
          }
          else if(indel1[k]=='-'){
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          	delet_inf += tem + "," + ref_read1[i] + ";";
            i++;k++;j--;
          }
          else{
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          		inser_inf += tem + "," + indel1[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
              k++;
              j++;
          }
      	}
      	while(indel1.count(k)>0){
          int num = k+j;
          string tem = boost::lexical_cast<string>(num);
          inser_inf += tem + "," + indel1[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
          k++;
          j++;
      	}
      	if(inser_inf.empty()){
      		Infor_outfile<<"-"<<"\t";
      	}else{
      		Infor_outfile<<inser_inf<<"\t";
      	}
      	if(delet_inf.empty()){
      		Infor_outfile<<"-"<<endl;
      	}else{
      		Infor_outfile<<delet_inf<<endl;
      	}
    	}
			
			//output read file2
			//text output
			if(!InputParameter.Output_type){
//				Outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos1.size(); i++)
//  			{
//  				Outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
//  			}
				Outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
  			Outfile2<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file1
//				Outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length-r2_slen+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos2.size(); i++)
//  			{
//  				Outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
//  			}
				Outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
  			Outfile1<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
			}else{
				//*.gz output
				//output read file2
//				Gz_outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos1.size(); i++)
//  			{
//  				Gz_outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
//  			}
				Gz_outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
  			Gz_outfile2<<endl<<output_read1<<endl
    			<<"+"<<endl
    			<<output_quality_seq1<<endl;
    		
    		//output read file1
//				Gz_outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length-r2_slen+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos2.size(); i++)
//  			{
//  				Gz_outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
//  			}
				Gz_outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
  			Gz_outfile1<<endl<<output_read2<<endl
    			<<"+"<<endl
    			<<output_quality_seq2<<endl;
			}
		}
	}
	cerr<<"Finish output reads"<<endl;
	return reads_count;
}


uint64_t simulate_fa_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, int i_or_I, uint64_t reads_all)
{
	int whether_check_seq = 0; 
	if(!check_seq(seq)){
		whether_check_seq = 1;
	}
	
	uint64_t reads_count=0;
	cerr<<"Begin to output reads"<<endl;
	for(uint64_t pair_count=0; pair_count < rd_pair; pair_count++)
	{
		//simulate insertsize
		int insertsize = simulate_insertsize(InputParameter.Insertsize_mean,InputParameter.Insertsize_sd);
		if (insertsize<InputParameter.Read_length){pair_count--;continue;}
		if (seqlen<insertsize){return reads_count;}
		uint64_t N = 1000000000000;
		uint64_t pos = (uint64_t)(((uint64_t)((double)rand() / double(RAND_MAX) * N)) % seqlen);
		if (pos+insertsize>seqlen){pair_count--;continue;}
			
		//get insert seq
		string sub_str=seq.substr(pos,insertsize);
		
		int selection=int(rand()%2); //0 or 1, for selecting output file randomly
		
		string ref_read1, ref_read2;
		int r1_slen, r2_slen;
		map<int,char,less<int> > indel1;
		map<int,char,less<int> > indel2;
		if(selection == 0){
  		r1_slen = simulate_reads_indel(Vec_del_rate1, Vec_ins_rate1, indel1, InputParameter.Read_length);
  		ref_read1=sub_str.substr(0, InputParameter.Read_length-r1_slen);
  		
  		r2_slen = simulate_reads_indel(Vec_del_rate2, Vec_ins_rate2, indel2, InputParameter.Read_length);
  		ref_read2=sub_str.substr(insertsize-InputParameter.Read_length+r2_slen, InputParameter.Read_length-r2_slen);
		}else{
  		r1_slen = simulate_reads_indel(Vec_del_rate2, Vec_ins_rate2, indel1, InputParameter.Read_length);
  		ref_read1=sub_str.substr(0, InputParameter.Read_length-r1_slen);
  		
  		r2_slen = simulate_reads_indel(Vec_del_rate1, Vec_ins_rate1, indel2, InputParameter.Read_length);
  		ref_read2=sub_str.substr(insertsize-InputParameter.Read_length+r2_slen, InputParameter.Read_length-r2_slen);
		}
		
		//check whether contain 'N' or nonbase char
		if(whether_check_seq && (!check_seq(ref_read1) || !check_seq(ref_read2))){
			pair_count--;
			continue;
		}
		
		//simulate GC bias
		if(InputParameter.Is_simulate_GC_bias){
			string check_seq = ref_read1+ref_read2;
			if(simulate_GC_bias(check_seq,GC_bias_abundance)){pair_count--;continue;}
		}
		
	  string read1;
		string read2;
		
		
		//insertsize statistics
		if(InsertSize_distr[insertsize]>0)
		{
			InsertSize_distr[insertsize]++;
		}else{
			InsertSize_distr[insertsize] = 1;
		}
		
		reads_count++;
		
		if ( InputParameter.Is_cyclization == 1 )
		{
			ref_read1=reversecomplementary(ref_read1);
			read1=ref2read(ref_read1, indel1);
			read2=ref2read(ref_read2, indel2);
		}else if (InputParameter.Insertsize_mean>0)
		{
			read1=ref2read(ref_read1, indel1);
			ref_read2=reversecomplementary(ref_read2);
			read2=ref2read(ref_read2, indel2);
		}else{
			cout<<"Error:insertsize mean is smaller than 0"<<endl;
			exit(-1);
		}

		string output_read1, output_read2;
		
		//simulate read1
		vector<int> error_pos1;
		vector<char> raw_base1;
		for(int i = 0; i < InputParameter.Read_length; i++)
		{
			double num=double(rand())/double(RAND_MAX);
			char ref_base = read1[i];
			int cycle;
			if(selection == 0){
				cycle = i;
			}else{
				cycle = i+Simulate_Cycle_num/2;
			}
			
			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num, num);
			char call_base = Bases[location];
			if(ref_base != call_base){
				if(selection == 0){
					Error_pos_distr[i+1]++;
				}else{
					Error_pos_distr[i+1+InputParameter.Read_length]++;
				}
				error_pos1.push_back(i);
				raw_base1.push_back(ref_base);
			}
			output_read1.push_back(call_base);
		}
		
		//simulate read2
		vector<int> error_pos2;
		vector<char> raw_base2;
		for(int i = 0; i < InputParameter.Read_length; i++)
		{
			double num=double(rand())/double(RAND_MAX);
			char ref_base = read2[i];
			int cycle;
			if(selection == 0){
				cycle = i+Simulate_Cycle_num/2;
			}else{
				cycle = i;
			}
			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num, num);
			char call_base = Bases[location];
			if(ref_base != call_base){
				if(selection == 0){
					Error_pos_distr[i+1+InputParameter.Read_length]++;
				}else{
					Error_pos_distr[i+1]++;
				}
				error_pos2.push_back(i);
				raw_base2.push_back(ref_base);
			}
			output_read2.push_back(call_base);
		}
		
		//output simulate reads
		if (reads_count%10000==0)
		{
			cerr<<"Output "<<reads_count<<" pair reads"<<endl;
		}
		
  	//output read file
		if(selection == 0){
			//output read file1
			//text output
			
			//read1 information
			Infor_outfile<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<"+"<<"\t"<<pos+1<<"\t";
  		for(int i = 0; i < error_pos1.size(); i++)
  		{
  			Infor_outfile<<error_pos1[i]+1<<","<<raw_base1[i]<<"->"<< output_read1[error_pos1[i]] <<";";
  		}
  		if(error_pos1.size() == 0){
  			Infor_outfile<<"-";
  		}
  		Infor_outfile<<"\t";
  		
  		if(indel1.size() == 0){
  			Infor_outfile<<"-"<<"\t"<<"-";
  		}else{
  			string inser_inf;
  			string delet_inf;
    		int k=0;
    		int j=0;
      	for(size_t i=0; i<ref_read1.size();){
          //cout<<i<<"\t"<<k<<endl;
          if(indel1.count(k)==0){
             i++; k++; 
          }
          else if(indel1[k]=='-'){
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          	delet_inf += tem + "," + ref_read1[i] + ";";
            i++;k++;j--;
          }
          else{
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          		inser_inf += tem + "," + indel1[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
              k++;
              j++;
          }
      	}
      	while(indel1.count(k)>0){
          int num = k+j;
          string tem = boost::lexical_cast<string>(num);
          inser_inf += tem + "," + indel1[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
          k++;
          j++;
      	}
      	if(inser_inf.empty()){
      		Infor_outfile<<"-"<<"\t";
      	}else{
      		Infor_outfile<<inser_inf<<"\t";
      	}
      	if(delet_inf.empty()){
      		Infor_outfile<<"-";
      	}else{
      		Infor_outfile<<delet_inf;
      	}
    	}
    	Infor_outfile<<endl;
    	
    	//read2 information
			Infor_outfile<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<"-"<<"\t"<<pos+insertsize-InputParameter.Read_length-r2_slen+1<<"\t";
  		for(int i = 0; i < error_pos2.size(); i++)
  		{
  			Infor_outfile<<error_pos2[i]+1<<","<<raw_base2[i]<<"->"<< output_read2[error_pos2[i]] <<";";
  		}
  		if(error_pos2.size() == 0){
  			Infor_outfile<<"-";
  		}
  		Infor_outfile<<"\t";
  		
  		if(indel2.size() == 0){
  			Infor_outfile<<"-"<<"\t"<<"-"<<endl;
  		}else{
  			string inser_inf;
  			string delet_inf;
    		int k=0;
    		int j=0;
      	for(size_t i=0; i<ref_read2.size();){
          //cout<<i<<"\t"<<k<<endl;
          if(indel2.count(k)==0){
             i++; k++; 
          }
          else if(indel2[k]=='-'){
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          	delet_inf += tem + "," + ref_read2[i] + ";";
            i++;k++;j--;
          }
          else{
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          		inser_inf += tem + "," + indel2[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
              k++;
              j++;
          }
      	}
      	while(indel2.count(k)>0){
          int num = k+j;
          string tem = boost::lexical_cast<string>(num);
          inser_inf += tem + "," + indel2[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
          k++;
          j++;
      	}
      	if(inser_inf.empty()){
      		Infor_outfile<<"-"<<"\t";
      	}else{
      		Infor_outfile<<inser_inf<<"\t";
      	}
      	if(delet_inf.empty()){
      		Infor_outfile<<"-"<<endl;
      	}else{
      		Infor_outfile<<delet_inf<<endl;
      	}
    	}
    	
    	//output read file
			if(!InputParameter.Output_type){

//  			Outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos1.size(); i++)
//  			{
//  				Outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
//  			}
				Outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
  			Outfile1<<endl<<output_read1<<endl;
    		
    		//output read file2
//  			Outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos2.size(); i++)
//  			{
//  				Outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
//  			}
				Outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
  			Outfile2<<endl<<output_read2<<endl;
  		}else{//*.gz output
//				Gz_outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos1.size(); i++)
//  			{
//  				Gz_outfile1<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
//  			}
				Gz_outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
  			Gz_outfile1<<endl<<output_read1<<endl;
    		
    		//output read file2
//				Gz_outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos2.size(); i++)
//  			{
//  				Gz_outfile2<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
//  			}
				Gz_outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
  			Gz_outfile2<<endl<<output_read2<<endl;
  		}
		
		}else{
			//output read file2
			//text output
			
			//read1 information
			Infor_outfile<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<"-"<<"\t"<<pos+insertsize-InputParameter.Read_length-r1_slen+1<<"\t";
  		for(int i = 0; i < error_pos2.size(); i++)
  		{
  			Infor_outfile<<error_pos2[i]+1<<","<<raw_base2[i]<<"->"<< output_read2[error_pos2[i]] <<";";
  		}
  		if(error_pos2.size() == 0){
  			Infor_outfile<<"-";
  		}
  		Infor_outfile<<"\t";
  		
  		if(indel2.size() == 0){
  			Infor_outfile<<"-"<<"\t"<<"-";
  		}else{
  			string inser_inf;
  			string delet_inf;
    		int k=0;
    		int j=0;
      	for(size_t i=0; i<ref_read2.size();){
          //cout<<i<<"\t"<<k<<endl;
          if(indel2.count(k)==0){
             i++; k++; 
          }
          else if(indel2[k]=='-'){
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          	delet_inf += tem + "," + ref_read2[i] + ";";
            i++;k++;j--;
          }
          else{
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          		inser_inf += tem + "," + indel2[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
              k++;
              j++;
          }
      	}
      	while(indel2.count(k)>0){
          int num = k+j;
          string tem = boost::lexical_cast<string>(num);
          inser_inf += tem + "," + indel2[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
          k++;
          j++;
      	}
      	if(inser_inf.empty()){
      		Infor_outfile<<"-"<<"\t";
      	}else{
      		Infor_outfile<<inser_inf<<"\t";
      	}
      	if(delet_inf.empty()){
      		Infor_outfile<<"-";
      	}else{
      		Infor_outfile<<delet_inf;
      	}
    	}
    	Infor_outfile<<endl;
    	
    	//read2 information
			Infor_outfile<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<"+"<<"\t"<<pos+1<<"\t";
  		for(int i = 0; i < error_pos1.size(); i++)
  		{
//  			Infor_outfile<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
  			Infor_outfile<<error_pos1[i]+1<<","<<raw_base1[i]<<"->"<< output_read1[error_pos1[i]] <<";";
  		}
  		if(error_pos1.size() == 0){
  			Infor_outfile<<"-";
  		}
  		Infor_outfile<<"\t";
  		
  		if(indel1.size() == 0){
  			Infor_outfile<<"-"<<"\t"<<"-"<<endl;
  		}else{
  			string inser_inf;
  			string delet_inf;
    		int k=0;
    		int j=0;
      	for(size_t i=0; i<ref_read1.size();){
          //cout<<i<<"\t"<<k<<endl;
          if(indel1.count(k)==0){
             i++; k++; 
          }
          else if(indel1[k]=='-'){
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          	delet_inf += tem + "," + ref_read1[i] + ";";
            i++;k++;j--;
          }
          else{
          	int num = i+j;
          	string tem = boost::lexical_cast<string>(num);
          		inser_inf += tem + "," + indel1[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
              k++;
              j++;
          }
      	}
      	while(indel1.count(k)>0){
          int num = k+j;
          string tem = boost::lexical_cast<string>(num);
          inser_inf += tem + "," + indel1[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
          k++;
          j++;
      	}
      	if(inser_inf.empty()){
      		Infor_outfile<<"-"<<"\t";
      	}else{
      		Infor_outfile<<inser_inf<<"\t";
      	}
      	if(delet_inf.empty()){
      		Infor_outfile<<"-"<<endl;
      	}else{
      		Infor_outfile<<delet_inf<<endl;
      	}
    	}
    	
    	//output read file
			if(!InputParameter.Output_type){
//				Outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos1.size(); i++)
//  			{
//  				Outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
//  			}
				Outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
  			Outfile2<<endl<<output_read1<<endl;
    		
    		//output read file1
//				Outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos2.size(); i++)
//  			{
//  				Outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
//  			}
				Outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
  			Outfile1<<endl<<output_read2<<endl;
  			
			}else{//*.gz output
//				Gz_outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<" "<<id_seq<<" "<<pos+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos1.size(); i++)
//  			{
//  				Gz_outfile2<<error_pos1[i]+1<<","<<raw_base1[i]<<";";
//  			}
				Gz_outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
  			Gz_outfile2<<endl<<output_read1<<endl;
    		
    		//output read file1
//				Gz_outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<" "<<id_seq<<" "<<pos+insertsize-InputParameter.Read_length+1<<" "<<InputParameter.Read_length<<" "<<insertsize<<" ";
//  			for(int i = 0; i < error_pos2.size(); i++)
//  			{
//  				Gz_outfile1<<error_pos2[i]+1<<","<<raw_base2[i]<<";";
//  			}
				Gz_outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
  			Gz_outfile1<<endl<<output_read2<<endl;
			}
		}

	}
	cerr<<"Finish output reads"<<endl;
	return reads_count;
}
